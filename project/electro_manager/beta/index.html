<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electronics Inventory (Modular)</title>
    <!--
    <script crossorigin src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.5/purify.min.js">
-->
    </script>

    <script src="js/utils/sanitize-utils.js"></script>
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/idb.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/utils/ui-constants.js"></script>
    <script src="js/utils/form-helpers.js"></script>

    <script src="js/components/ComponentForm.js"></script>
    <script src="js/components/AdvancedFilters.js"></script>
    <script src="js/components/BulkEditForm.js"></script>
    <script src="js/components/InventoryView.js"></script>
    <script src="js/components/SettingsView.js"></script>
    <script src="js/components/FootprintManager.js"></script>
    <script src="js/components/LocationManager.js"></script>
    <script src="js/components/LocationPage.js"></script>
    <script src="js/components/DrawerManager.js"></script>
    <script src="js/components/DrawerView.js"></script>
    <script src="js/components/DrawerPage.js"></script>
    <script src="js/components/ThemeSwitcher.js"></script>

    <script src="js/external/tailwind.js"></script>
    <script src="js/external/react18.development.js"></script>
    <script src="js/external/react-dom18.development.js"></script>
    <script src="js/external/babel.min.js"></script>
    <script src="js/external/purify325.min.js"></script>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        // Ensure App namespace and sub-namespaces exist
        window.App = window.App || {};
        window.App.utils = window.App.utils || {};
        window.App.components = window.App.components || {};

        // Destructure React hooks and loaded components/utils for easier use
        const { useState, useEffect, useCallback } = React;
        const { helpers } = window.App.utils;
        const { storage } = window.App.utils;
        const { UI } = window.App.utils || {};
        const { ComponentForm, BulkEditForm, InventoryView, SettingsView, DrawerPage, LocationPage } = window.App.components;

        // --- Main Application Component ---
        const ElectronicsInventory = () => {
            // --- State Variables ---
            const [components, setComponents] = useState([]);
            const [categories, setCategories] = useState([]);
            const [currentPage, setCurrentPage] = useState('inventory'); // 'inventory', 'locations', 'data', or 'drawers'
            const [viewMode, setViewMode] = useState('table'); // 'table' or 'card'
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            const [showForm, setShowForm] = useState(false); // For add/edit component modal
            const [editComponentData, setEditComponentData] = useState(null); // Data for the component being edited/added
            const [jsonData, setJsonData] = useState(''); // For import/export text area
            const [importError, setImportError] = useState(''); // Message after import attempt
            const [exportMessage, setExportMessage] = useState(''); // Message after export/save attempt
            const [lowStockConfig, setLowStockConfig] = useState({}); // { category: threshold }
            const [currencySymbol, setCurrencySymbol] = useState('$');
            const [showTotalValue, setShowTotalValue] = useState(false);
            const [selectedComponents, setSelectedComponents] = useState([]); // Array of selected component IDs for bulk actions
            const [showBulkEditForm, setShowBulkEditForm] = useState(false);
            const [locations, setLocations] = useState([]);
            const [selectedLocation, setSelectedLocation] = useState('all');
            const [footprints, setFootprints] = useState([]);
            const [drawers, setDrawers] = useState([]);
            const [cells, setCells] = useState([]);
            const [viewingDrawerId, setViewingDrawerId] = useState(null);
            const [itemsPerPage, setItemsPerPage] = useState('all');
            const [appTheme, setAppTheme] = useState(window.App.utils.UI.currentTheme);
            const [theme, setTheme] = useState(
                () => storage.loadConfig().theme
                    || window.App.utils.UI.currentTheme
                    || 'light'
            );

            // --- Effects ---
            // Initial load effect
            useEffect(() => {
                console.log("Initial load effect running with proper data ordering...");

                // Initialize storage first
                storage.init()
                    .then(function () {
                        console.log("Storage system initialized");

                        // Load all data from IndexedDB
                        Promise.all([
                            storage.loadComponents(),
                            storage.loadLocations(),
                            storage.loadDrawers(),
                            storage.loadCells(),
                            storage.loadCategories(),
                            storage.loadFootprints(),
                            storage.loadLowStockConfig() // Load directly from IndexedDB
                        ])
                            .then(function (results) {
                                var [
                                    loadedComponents,
                                    loadedLocations,
                                    loadedDrawers,
                                    loadedCells,
                                    loadedCategories,
                                    loadedFootprints,
                                    loadedLowStockConfig
                                ] = results;

                                console.log("Loaded all data:", {
                                    components: loadedComponents.length,
                                    locations: loadedLocations.length,
                                    drawers: loadedDrawers.length,
                                    cells: loadedCells.length,
                                    categories: loadedCategories.length,
                                    footprints: loadedFootprints.length, // FIXED: Changed from footedFootprints to loadedFootprints
                                    lowStockConfig: Object.keys(loadedLowStockConfig).length + " categories"
                                });

                                // Set state
                                setComponents(loadedComponents);
                                setLocations(loadedLocations);
                                setDrawers(loadedDrawers);
                                setCells(loadedCells);
                                setCategories(loadedCategories);
                                setFootprints(loadedFootprints);
                                setLowStockConfig(loadedLowStockConfig);

                                // Load other config from localStorage (without lowStockConfig)
                                var config = storage.loadConfig();
                                setViewMode(config.viewMode || 'table');
                                setCurrencySymbol(config.currencySymbol || 'RM');
                                setShowTotalValue(config.showTotalValue || false);
                                setItemsPerPage(config.itemsPerPage || 'all');

                                // ... rest of your code ...
                            });
                    });
            }, []);// Only run once

            useEffect(() => { (async () => setDrawers(await storage.loadDrawers()))(); }, []);
            useEffect(() => { (async () => await storage.saveCells(cells))(); }, [cells]);
            useEffect(() => { (async () => await storage.saveDrawers(drawers))(); }, [drawers]);

            // --- FOR COMPONENTS ---
            useEffect(() => {
                if (!components.length) return;

                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving components...", components.length);

                    storage.saveComponents(components)
                        .then(function (success) {
                            if (success) {
                                console.log("Components saved successfully");
                            } else {
                                console.warn("Failed to save components");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving components:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [components]);

            // --- FOR LOCATIONS ---
            useEffect(() => {
                if (!locations.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving locations...", locations.length);

                    storage.saveLocations(locations)
                        .then(function (success) {
                            if (success) {
                                console.log("Locations saved successfully");

                                // After locations are saved, make sure drawers are also saved
                                // to ensure references are maintained
                                if (drawers.length) {
                                    return storage.saveDrawers(drawers);
                                }
                            } else {
                                console.warn("Failed to save locations");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving locations:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [locations]);

            // --- FOR DRAWERS ---
            useEffect(() => {
                if (!drawers.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving drawers...", drawers.length);

                    storage.saveDrawers(drawers)
                        .then(function (success) {
                            if (success) {
                                console.log("Drawers saved successfully");

                                // After drawers are saved, make sure cells are also saved
                                // to ensure references are maintained
                                if (cells.length) {
                                    return storage.saveCells(cells);
                                }
                            } else {
                                console.warn("Failed to save drawers");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving drawers:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [drawers, cells]);

            // --- FOR CELLS ---
            useEffect(() => {
                if (!cells.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving cells...", cells.length);

                    storage.saveCells(cells)
                        .then(function (success) {
                            if (success) {
                                console.log("Cells saved successfully");
                            } else {
                                console.warn("Failed to save cells");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving cells:", err);
                        });
                }, 300); 
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [cells]);

            // --- FOR CATEGORY ---
            useEffect(() => {
                if (!categories.length) return;
                storage.saveCategories(categories)
                    .then(function (success) {
                        if (success) {
                            console.log("Categories saved to IndexedDB successfully:", categories.length);
                        } else {
                            console.warn("Failed to save categories to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving categories to IndexedDB:", err);
                    });
            }, [categories]);

            // --- FOR FOOTPRINT ---
            useEffect(() => {
                if (!footprints.length) return;

                // Save directly to IndexedDB
                storage.saveFootprints(footprints)
                    .then(function (success) {
                        if (success) {
                            console.log("Footprints saved to IndexedDB successfully:", footprints.length);
                        } else {
                            console.warn("Failed to save footprints to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving footprints to IndexedDB:", err);
                    });
            }, [footprints]);
            
            // ---LOW CONFIG---
            useEffect(() => {
                // Skip if empty
                if (!lowStockConfig || Object.keys(lowStockConfig).length === 0) return;

                // Save to IndexedDB only
                storage.saveLowStockConfig(lowStockConfig)
                    .then(function (success) {
                        if (success) {
                            console.log("Low stock config saved to IndexedDB successfully");
                        } else {
                            console.warn("Failed to save low stock config to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving low stock config to IndexedDB:", err);
                    });
            }, [lowStockConfig]);

            // ---SAVE CONFIG---
            // For configuration (still synchronous)
            useEffect(() => {
                var config = {
                    categories,
                    viewMode,
                    lowStockConfig,
                    currencySymbol,
                    showTotalValue,
                    footprints,
                    itemsPerPage,
                    theme
                };

                var success = storage.saveConfig(config);
                if (success) {
                    console.log("Config saved to localStorage");
                } else {
                    console.warn("Failed to save config");
                }
            }, [categories, viewMode, lowStockConfig, currencySymbol, showTotalValue, footprints, itemsPerPage, theme]);

            const saveConfigCallback = useCallback(() => {
                // To IndexedDB
                Promise.all([
                    storage.saveCategories(categories),
                    storage.saveFootprints(footprints),
                    storage.saveLowStockConfig(lowStockConfig)
                ]).catch(function (err) {
                    console.error("Error saving to IndexedDB:", err);
                });
                // Config to localStorage
                storage.saveConfig({
                    viewMode,
                    currencySymbol,
                    showTotalValue,
                    itemsPerPage,
                    theme
                });
            }, [categories, footprints, lowStockConfig, viewMode, currencySymbol, showTotalValue, itemsPerPage, theme]);

            const saveComponentsCallback = useCallback(() => {
                storage.saveComponents(components);
            }, [components]);

            const handleItemsPerPageChange = useCallback((value) => {
                setItemsPerPage(value);
            }, []);

            useEffect(() => {
                // Apply theme through the UI system
                window.App.utils.UI.setTheme(theme);

                // Save theme preference (handled inside setTheme too, but for extra safety)
                localStorage.setItem('electronicsTheme', theme);

                // Log theme change for debugging
                console.log(`Theme applied: ${theme}`);
            }, [theme]);


            // --- Helper Functions / Callbacks for Child Components ---
            // Get Theme
            const getThemeColors = () => {
                // Check if UI and getThemeColors exist
                if (UI && typeof UI.getThemeColors === 'function') {
                    return UI.getThemeColors();
                }
                // Fallback if UI is not available
                return {
                    textPrimary: 'gray-900',
                    textSecondary: 'gray-700',
                    textMuted: 'gray-500',
                    primary: 'blue-500',
                    border: 'gray-300',
                    background: 'gray-100'
                };
            };

            // Get the theme colors
            const themeColors = getThemeColors();

            // Clear status messages (import/export)
            const clearStatusMessages = () => {
                setImportError('');
                setExportMessage('');
            };

            // --- Component CRUD Callbacks ---
            const handleAddComponent = () => {
                clearStatusMessages();
                // Prepare initial data for the form (empty component)
                setEditComponentData({
                    id: '', name: '', category: '', customCategory: '', type: '', quantity: 0, price: 0,
                    footprint: '', customFootprint: '', parameters: '', info: '', datasheets: '', image: ''
                });
                setShowForm(true);
            };

            const handleEditComponent = (componentToEdit) => {
                clearStatusMessages();

                // Create a deep copy of the component
                const cleanComponent = { ...componentToEdit };

                // Ensure locationInfo is a proper object
                if (!cleanComponent.locationInfo ||
                    typeof cleanComponent.locationInfo === 'string' ||
                    cleanComponent.locationInfo === '[object Object]') {
                    cleanComponent.locationInfo = { locationId: '', details: '' };
                }

                // Ensure storageInfo is a proper object
                if (!cleanComponent.storageInfo ||
                    typeof cleanComponent.storageInfo === 'string' ||
                    cleanComponent.storageInfo === '[object Object]') {
                    cleanComponent.storageInfo = { locationId: '', drawerId: '', cells: [] };
                } else {
                    // Handle partial storageInfo objects that might be missing the cells array
                    cleanComponent.storageInfo = {
                        locationId: cleanComponent.storageInfo.locationId || '',
                        drawerId: cleanComponent.storageInfo.drawerId || '',
                        cells: Array.isArray(cleanComponent.storageInfo.cells)
                            ? cleanComponent.storageInfo.cells
                            : []
                    };

                    // Handle backward compatibility - if cellId exists but cells array doesn't include it
                    if (cleanComponent.storageInfo.cellId &&
                        !cleanComponent.storageInfo.cells.includes(cleanComponent.storageInfo.cellId)) {
                        cleanComponent.storageInfo.cells.push(cleanComponent.storageInfo.cellId);
                    }
                }

                // Ensure flag fields exist
                cleanComponent.favorite = cleanComponent.favorite || false;
                cleanComponent.bookmark = cleanComponent.bookmark || false;
                cleanComponent.star = cleanComponent.star || false;

                // Determine if the footprint is custom
                const isCustomFootprint = cleanComponent.footprint &&
                    !footprints.includes(cleanComponent.footprint);

                // Prepare data for the form, formatting parameters
                setEditComponentData({
                    ...cleanComponent,
                    price: Number(cleanComponent.price) || 0, // Ensure price is number
                    quantity: Number(cleanComponent.quantity) || 0, // Ensure quantity is number
                    customCategory: '', // Reset custom field initially
                    // Set footprint dropdown value and custom input value
                    footprint: isCustomFootprint ? '__custom__' : (cleanComponent.footprint || ''),
                    customFootprint: isCustomFootprint ? cleanComponent.footprint : '',
                    // Format additional parameters for the textarea
                    parameters: helpers.formatParametersForEdit(cleanComponent)
                });
                setShowForm(true);
            };

            // Update to handleSaveComponent
            const handleSaveComponent = (componentDataFromForm) => {
                clearStatusMessages();
                let categoryToSave = componentDataFromForm.category;
                let footprintToSave = componentDataFromForm.footprint;
                let newCategoryAdded = false;

                // Handle custom category
                if (componentDataFromForm.category === '__custom__' && componentDataFromForm.customCategory) {
                    categoryToSave = componentDataFromForm.customCategory.trim();
                    if (categoryToSave && !categories.includes(categoryToSave)) {
                        setCategories(prev => [...prev, categoryToSave].sort());
                        newCategoryAdded = true; // Mark that we might need to revert if save fails
                    } else if (!categoryToSave) {
                        // Handle case where custom is selected but input is empty
                        alert("New category name cannot be empty.");
                        return; // Prevent saving
                    }
                }

                // Handle custom footprint
                if (componentDataFromForm.footprint === '__custom__' && componentDataFromForm.customFootprint) {
                    footprintToSave = componentDataFromForm.customFootprint.trim();
                    if (!footprintToSave) {
                        alert("Custom footprint name cannot be empty.");
                        if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave)); // Revert category add if needed
                        return; // Prevent saving
                    }
                } else if (componentDataFromForm.footprint === '__custom__') {
                    // Custom selected but input empty - treat as no footprint selected
                    footprintToSave = '';
                }

                // Basic validation
                if (!componentDataFromForm.name || !categoryToSave) {
                    alert("Component Name and Category are required.");
                    // Revert category addition if validation fails
                    if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave));
                    return;
                }

                // Ensure locationInfo is properly formatted
                let locationInfo = componentDataFromForm.locationInfo;
                if (!locationInfo || typeof locationInfo === 'string' || locationInfo === '[object Object]') {
                    locationInfo = { locationId: '', details: '' };
                }

                // Process the storage information
                let storageInfo = componentDataFromForm.storageInfo;
                if (!storageInfo || typeof storageInfo === 'string' || storageInfo === '[object Object]') {
                    storageInfo = { locationId: '', drawerId: '', cells: [] };
                }

                // Ensure we store storage information properly
                const finalStorageInfo = {
                    locationId: storageInfo.locationId || '',
                    drawerId: storageInfo.drawerId || '',
                    cells: Array.isArray(storageInfo.cells) ? storageInfo.cells : []
                };

                // For backward compatibility with older components
                if (storageInfo.cellId && !finalStorageInfo.cells.includes(storageInfo.cellId)) {
                    finalStorageInfo.cells.push(storageInfo.cellId);
                }

                // Prepare the final component object
                const finalComponent = {
                    // Core fields
                    id: componentDataFromForm.id || helpers.generateId(), // Generate ID if new
                    name: componentDataFromForm.name.trim(),
                    favorite: componentDataFromForm.favorite || false,
                    bookmark: componentDataFromForm.bookmark || false,
                    star: componentDataFromForm.star || false,
                    category: categoryToSave,
                    type: componentDataFromForm.type.trim(),
                    quantity: parseInt(componentDataFromForm.quantity, 10) || 0,
                    price: parseFloat(componentDataFromForm.price) || 0,
                    footprint: footprintToSave,
                    info: (componentDataFromForm.info || '').trim(),
                    datasheets: componentDataFromForm.datasheets.trim(),
                    image: componentDataFromForm.image.trim(),
                    // Add location and storage information
                    locationInfo: locationInfo,
                    storageInfo: finalStorageInfo
                };

                // Add additional parameters, but filter out any special fields that might have been incorrectly included
                const additionalParams = helpers.parseParameters(componentDataFromForm.parameters);
                // Remove any properties that would conflict with core properties
                Object.keys(additionalParams).forEach(key => {
                    if (finalComponent.hasOwnProperty(key)) {
                        console.warn(`Parameter '${key}' conflicts with a core property and will be ignored.`);
                        delete additionalParams[key];
                    }
                });
                // Now add the filtered parameters
                Object.assign(finalComponent, additionalParams);

                // Update state: either replace existing or add new
                if (componentDataFromForm.id) { // Editing existing component
                    setComponents(prev => prev.map(comp =>
                        comp.id === componentDataFromForm.id ? finalComponent : comp
                    ));
                } else { // Adding new component
                    setComponents(prev => [...prev, finalComponent]);
                }

                // Close form and reset edit state
                setShowForm(false);
                setEditComponentData(null);
                setExportMessage(componentDataFromForm.id ? 'Component updated.' : 'Component added.');
            };

            const handleDeleteComponent = (idToDelete) => {
                clearStatusMessages();
                if (window.confirm('Are you sure you want to delete this component? This action cannot be undone.')) {
                    setComponents(prev => prev.filter(comp => comp.id !== idToDelete));
                    // Also remove from selection if it was selected
                    setSelectedComponents(prev => prev.filter(selId => selId !== idToDelete));
                    setExportMessage('Component deleted.');
                }
            };

            const handleUpdateQuantity = (id, delta) => {
                // No need to clear messages for this frequent action
                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        const currentQuantity = Number(comp.quantity) || 0;
                        // Prevent quantity from going below zero
                        return { ...comp, quantity: Math.max(0, currentQuantity + delta) };
                    }
                    return comp;
                }));
            };

            const handleToggleFavorite = (id, property) => {
                if (!['favorite', 'bookmark', 'star'].includes(property)) return;

                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        // Toggle the property
                        return {
                            ...comp,
                            [property]: !(comp[property] || false)
                        };
                    }
                    return comp;
                }));
            };

            useEffect(() => {
                storage.saveLocations(locations);
            }, [locations]);

            // --- Bulk Action Callbacks ---
            const handleToggleSelect = (id) => {
                setSelectedComponents(prev =>
                    prev.includes(id) ? prev.filter(selId => selId !== id) : [...prev, id]
                );
            };

            const handleToggleSelectAll = () => {
                // Filter components based on current view filters *before* selecting all
                const currentlyFilteredIds = components
                    .filter(component => {
                        const matchesCategory = selectedCategory === 'all' || component.category === selectedCategory;
                        const lowerSearchTerm = searchTerm.toLowerCase();
                        const matchesSearch = !searchTerm ||
                            (component.name && component.name.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.type && component.type.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.category && component.category.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.info && component.info.toLowerCase().includes(lowerSearchTerm));
                        return matchesCategory && matchesSearch;
                    })
                    .map(comp => comp.id);

                if (selectedComponents.length === currentlyFilteredIds.length && currentlyFilteredIds.length > 0) {
                    // If all filtered are selected, deselect all
                    setSelectedComponents([]);
                } else {
                    // Otherwise, select all filtered
                    setSelectedComponents(currentlyFilteredIds);
                }
            };

            const handleBulkEdit = () => {
                clearStatusMessages();
                if (selectedComponents.length === 0) return;
                setShowBulkEditForm(true); // Open the bulk edit modal
            };

            const handleApplyBulkEdit = (bulkEditData) => {
                clearStatusMessages();
                let categoryToApply = bulkEditData.category;
                let footprintToApply = bulkEditData.footprint;
                let newCategoryAdded = false;

                // Handle custom category from bulk edit
                if (bulkEditData.category === '__custom__' && bulkEditData.customCategory) {
                    categoryToApply = bulkEditData.customCategory.trim();
                    if (categoryToApply && !categories.includes(categoryToApply)) {
                        setCategories(prev => [...prev, categoryToApply].sort());
                        newCategoryAdded = true;
                    } else if (!categoryToApply) {
                        // Don't apply if custom is selected but name is empty
                        categoryToApply = ''; // Effectively means "keep existing"
                    }
                }

                // Handle custom footprint from bulk edit
                if (bulkEditData.footprint === '__custom__' && bulkEditData.customFootprint) {
                    footprintToApply = bulkEditData.customFootprint.trim();
                    if (!footprintToApply) footprintToApply = ''; // Treat empty custom as no change
                } else if (bulkEditData.footprint === '__custom__') {
                    footprintToApply = ''; // Treat empty custom as no change
                }

                setComponents(prevComponents => prevComponents.map(comp => {
                    // Apply changes only to selected components
                    if (selectedComponents.includes(comp.id)) {
                        const updates = {};

                        // Apply Category (if specified and valid)
                        if (categoryToApply && categoryToApply !== '__custom__') {
                            updates.category = categoryToApply;
                        }

                        // Apply Type (if specified)
                        if (bulkEditData.type.trim()) {
                            updates.type = bulkEditData.type.trim();
                        }

                        // Apply Footprint (if specified and valid)
                        if (footprintToApply && footprintToApply !== '__custom__') {
                            updates.footprint = footprintToApply;
                        }

                        // Apply Quantity Adjustment
                        if (bulkEditData.quantity !== '' && !isNaN(bulkEditData.quantity)) {
                            const changeValue = parseInt(bulkEditData.quantity, 10) || 0;
                            const currentQuantity = Number(comp.quantity) || 0;
                            if (bulkEditData.quantityAction === 'set') {
                                updates.quantity = Math.max(0, changeValue);
                            } else if (bulkEditData.quantityAction === 'increment') {
                                updates.quantity = currentQuantity + changeValue;
                            } else if (bulkEditData.quantityAction === 'decrement') {
                                updates.quantity = Math.max(0, currentQuantity - changeValue);
                            }
                        }

                        // Apply Price Adjustment
                        if (bulkEditData.price !== '' && !isNaN(bulkEditData.price)) {
                            const priceChangeValue = parseFloat(bulkEditData.price) || 0;
                            const currentPrice = Number(comp.price) || 0;
                            if (bulkEditData.priceAction === 'set') {
                                updates.price = Math.max(0, priceChangeValue); // Ensure non-negative
                            } else if (bulkEditData.priceAction === 'increase') {
                                updates.price = Math.max(0, currentPrice + priceChangeValue);
                            } else if (bulkEditData.priceAction === 'decrease') {
                                updates.price = Math.max(0, currentPrice - priceChangeValue);
                            }
                        }

                        // Apply Favorite status (if defined)
                        if (bulkEditData.favorite !== null) {
                            updates.favorite = bulkEditData.favorite;
                        }

                        // Apply Bookmark status (if defined)
                        if (bulkEditData.bookmark !== null) {
                            updates.bookmark = bulkEditData.bookmark;
                        }

                        // Apply Star status (if defined)
                        if (bulkEditData.star !== null) {
                            updates.star = bulkEditData.star;
                        }

                        // --- Apply Location Updates ---

                        // Initialize locationInfo if needed
                        if (!comp.locationInfo || typeof comp.locationInfo === 'string' || comp.locationInfo === '[object Object]') {
                            comp.locationInfo = { locationId: '', details: '' };
                        }

                        // Handle location changes
                        if (bulkEditData.locationAction === 'clear') {
                            // Clear location information
                            updates.locationInfo = { locationId: '', details: '' };
                        } else if (bulkEditData.locationAction === 'set' && bulkEditData.locationId) {
                            // Set to a new location
                            updates.locationInfo = {
                                locationId: bulkEditData.locationId,
                                details: bulkEditData.locationDetails || ''
                            };
                        }

                        // --- Apply Storage/Drawer/Cell Updates ---

                        // Initialize storageInfo if needed
                        if (!comp.storageInfo || typeof comp.storageInfo === 'string' || comp.storageInfo === '[object Object]') {
                            comp.storageInfo = { locationId: '', drawerId: '', cells: [] };
                        } else if (!Array.isArray(comp.storageInfo.cells)) {
                            comp.storageInfo.cells = [];
                        }

                        // Handle storage actions
                        if (bulkEditData.storageAction === 'clear') {
                            // Clear drawer assignment
                            updates.storageInfo = {
                                locationId: '',
                                drawerId: '',
                                cells: []
                            };
                        } else if (bulkEditData.storageAction === 'set') {
                            // Set to new drawer and cells
                            if (bulkEditData.storageLocationId) {
                                const newStorageInfo = {
                                    locationId: bulkEditData.storageLocationId,
                                    drawerId: bulkEditData.drawerId || '',
                                    cells: bulkEditData.drawerId ? bulkEditData.selectedCells : []
                                };
                                updates.storageInfo = newStorageInfo;
                            }
                        }

                        // Return the component with applied updates
                        return { ...comp, ...updates };
                    }
                    // Return unchanged component if not selected
                    return comp;
                }));

                // Close the bulk edit form and clear selection
                setShowBulkEditForm(false);
                setSelectedComponents([]);
                setExportMessage(`${selectedComponents.length} component(s) updated.`);
            };
            const handleBulkDelete = () => {
                clearStatusMessages();
                if (selectedComponents.length === 0) return;
                if (window.confirm(`Are you sure you want to delete ${selectedComponents.length} selected component(s)? This action cannot be undone.`)) {
                    setComponents(prev => prev.filter(comp => !selectedComponents.includes(comp.id)));
                    const deletedCount = selectedComponents.length; // Store count before clearing
                    setSelectedComponents([]); // Clear selection
                    setExportMessage(`${deletedCount} component(s) deleted.`);
                }
            };

            //-- Location Management--
            const handleAddLocation = (newLocation) => {
                clearStatusMessages();
                setLocations(prev => [...prev, newLocation]);
                setExportMessage('Location added.');
            };

            const handleEditLocation = (locationId, updatedLocation) => {
                clearStatusMessages();
                setLocations(prev => prev.map(loc =>
                    loc.id === locationId ? updatedLocation : loc
                ));
                setExportMessage('Location updated.');
            };

            const handleDeleteLocation = (locationId) => {
                clearStatusMessages();

                // Check if any components are assigned to this location
                const assignedComponents = components.filter(comp =>
                    comp.locationInfo && comp.locationInfo.locationId === locationId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This location has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the location from these components. Continue?`
                    : 'Are you sure you want to delete this location?';

                if (window.confirm(message)) {
                    // Clear location from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.locationInfo && comp.locationInfo.locationId === locationId) {
                                // Return component with cleared location
                                return {
                                    ...comp,
                                    locationInfo: null
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the location
                    setLocations(prev => prev.filter(loc => loc.id !== locationId));
                    setExportMessage(`Location deleted. ${assignedComponents.length > 0 ? `Location cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            //--Drawer Management

            // Add handlers for drawers
            const handleAddDrawer = (newDrawer) => {
                clearStatusMessages();

                setDrawers(prev => [...prev, newDrawer]);

                const newCells = window.App.utils.helpers.generateCellsForDrawer(newDrawer);
                setCells(prev => [...prev, ...newCells]);

                setExportMessage(
                    `Drawer “${newDrawer.name}” added with ${newCells.length} empty cell${newCells.length !== 1 ? 's' : ''}.`
                );
            };

            const handleEditDrawer = (updated) => {

                setDrawers(prev => {
                    const list = prev.map(d => d.id === updated.id ? updated : d);
                    storage.saveDrawers(list);
                    return list;
                });


                setCells(prevCells => {
                    const next = window.App.utils.helpers.syncCellsWithDrawer(
                        updated,
                        prevCells,
                        components          // ← current components array from state
                    );
                    storage.saveCells(next);
                    return next;
                });
            };


            const handleDeleteDrawer = (drawerId) => {
                clearStatusMessages();

                // Check if any components are assigned to this drawer
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.drawerId === drawerId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This drawer has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the drawer from these components. Continue?`
                    : 'Are you sure you want to delete this drawer?';

                if (window.confirm(message)) {
                    // Clear drawer from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.drawerId === drawerId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        drawerId: '',
                                        cellId: ''  // Also clear cell if drawer is deleted
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Also delete all cells belonging to this drawer
                    setCells(prev => prev.filter(cell => cell.drawerId !== drawerId));

                    // Remove the drawer
                    setDrawers(prev => prev.filter(drawer => drawer.id !== drawerId));
                    setExportMessage(`Drawer deleted. ${assignedComponents.length > 0 ? `Drawer cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            // Add handlers for cells
            const handleAddCell = (newCell) => {
                clearStatusMessages();
                setCells(prev => [...prev, newCell]);
                setExportMessage('Cell added.');
            };

            const handleEditCell = (cellId, updatedCell) => {
                clearStatusMessages();
                setCells(prev => prev.map(cell =>
                    cell.id === cellId ? updatedCell : cell
                ));
                //available: existingCell.available !== undefined ? existingCell.available : true
                setExportMessage('Cell updated.');
            };

            const handleDeleteCell = (cellId) => {
                clearStatusMessages();

                // Check if any components are assigned to this cell
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.cellId === cellId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This cell has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the cell from these components. Continue?`
                    : 'Are you sure you want to delete this cell?';

                if (window.confirm(message)) {
                    // Clear cell from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.cellId === cellId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        cellId: ''  // Clear cell but keep drawer
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the cell
                    setCells(prev => prev.filter(cell => cell.id !== cellId));
                    setExportMessage(`Cell deleted. ${assignedComponents.length > 0 ? `Cell cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            const handleNavigateToDrawer = (drawerId) => {
                setCurrentPage('drawers'); // Change to drawer page
                // You need to expose this state variable to the DrawerPage
                setViewingDrawerId(drawerId);
            };

            //-- Theme Management--
            const handleThemeChange = (newTheme) => {
                if (window.App.utils.UI.themes[newTheme]) {
                    // Update state
                    setTheme(newTheme);

                    // Get the body element
                    const bodyElement = document.body;

                    // Get theme colors
                    const themeColors = window.App.utils.UI.getThemeColors();

                    // Remove all existing theme-related classes from body
                    bodyElement.classList.remove('bg-gray-100', 'bg-gray-900');
                    bodyElement.classList.remove('text-gray-100', 'text-gray-900');

                    // Add the correct background class based on theme
                    if (newTheme === 'dark') {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    } else {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    }

                    // Update UI system
                    window.App.utils.UI.setTheme(newTheme);

                    // Save theme preference
                    saveConfigCallback();

                    // Force re-render to update components
                    setAppTheme(newTheme);
                }
            };

            // Set up global theme change handler
            window.App.onThemeChange = (newTheme) => {
                setAppTheme(newTheme);
            };

            useEffect(() => {
                // Get updated styles based on current theme
                window.App.utils.UI.buttons = window.App.utils.UI.getThemeStyles().buttons;
                window.App.utils.UI.cards = window.App.utils.UI.getThemeStyles().cards;
                window.App.utils.UI.typography = window.App.utils.UI.getThemeStyles().typography;
                // Update other style categories similarly

                // Apply theme class to body if needed
                document.body.className = `bg-${window.App.utils.UI.themes[appTheme].colors.background}`;
            }, [appTheme]);

            //-- Footprint Management---
            const handleAddFootprint = (newFootprint) => {
                clearStatusMessages();
                const trimmedFootprint = newFootprint.trim();
                if (!trimmedFootprint) {
                    setExportMessage('Footprint name cannot be empty.');
                    return;
                }
                if (footprints.includes(trimmedFootprint)) {
                    setExportMessage(`Footprint "${trimmedFootprint}" already exists.`);
                    return;
                }

                setFootprints(prev => [...prev, trimmedFootprint].sort());
                setExportMessage(`Footprint "${trimmedFootprint}" added.`);
            };

            const handleEditFootprint = (oldFootprint, newFootprint) => {
                clearStatusMessages();
                const trimmedNewFootprint = newFootprint.trim();
                if (!trimmedNewFootprint) {
                    setExportMessage('Footprint name cannot be empty.');
                    return;
                }
                if (footprints.includes(trimmedNewFootprint)) {
                    setExportMessage(`Footprint "${trimmedNewFootprint}" already exists.`);
                    return;
                }

                // Update footprint list
                setFootprints(prev => prev.map(fp => fp === oldFootprint ? trimmedNewFootprint : fp).sort());

                // Update components using the old footprint
                setComponents(prev => prev.map(comp =>
                    comp.footprint === oldFootprint ? { ...comp, footprint: trimmedNewFootprint } : comp
                ));

                setExportMessage(`Footprint "${oldFootprint}" renamed to "${trimmedNewFootprint}".`);
            };

            const handleDeleteFootprint = (footprintToDelete) => {
                clearStatusMessages();
                // Check if any components are using this footprint
                const componentsUsingFootprint = components.filter(comp => comp.footprint === footprintToDelete);

                if (componentsUsingFootprint.length > 0) {
                    const confirmMessage = `${componentsUsingFootprint.length} component(s) are using this footprint. Removing it will clear the footprint from these components. Continue?`;
                    if (!window.confirm(confirmMessage)) {
                        return;
                    }

                    // Clear footprint from components
                    setComponents(prev => prev.map(comp =>
                        comp.footprint === footprintToDelete ? { ...comp, footprint: '' } : comp
                    ));
                }

                // Remove the footprint from the list
                setFootprints(prev => prev.filter(fp => fp !== footprintToDelete));
                setExportMessage(`Footprint "${footprintToDelete}" deleted.`);
            };

            const handleRestoreDefaultFootprints = () => {
                clearStatusMessages();
                // Define the default footprints list here
                const defaultFootprints = [
                    "0603", "0805", "1206", "1210", "0402", "0201", "2512",
                    "SOT-23", "SOT-223", "SOT-89", "SOT-143",
                    "SOIC-8", "SOIC-16", "TSSOP-16", "TSSOP-20",
                    "DIP-8", "DIP-14", "DIP-16", "DIP-20", "DIP-28",
                    "QFP-32", "QFP-44", "QFP-64", "QFP-100",
                    "QFN-16", "QFN-20", "QFN-24", "QFN-32",
                    "TO-92", "TO-220", "TO-247", "TO-263", "TO-252"
                ];

                if (window.confirm('This will add common electronic component footprints to your list. Continue?')) {
                    // Merge current footprints with defaults to avoid duplicates
                    const merged = [...new Set([...defaultFootprints, ...footprints])].sort();
                    setFootprints(merged);
                    setExportMessage('Common footprints added to your list.');
                }
            };

            // --- Data Management Callbacks (Import/Export) ---
            const handleExportComponents = () => {
                clearStatusMessages();
                try {
                    // Make sure all objects are properly serialized as JSON objects
                    // Deep copy the components to avoid modifying the original objects
                    const componentsToExport = components.map(comp => {
                        // Create a deep copy of the component
                        const compCopy = { ...comp };

                        // Make sure locationInfo is a proper object, not a string
                        if (compCopy.locationInfo === '[object Object]' || typeof compCopy.locationInfo === 'string') {
                            compCopy.locationInfo = { locationId: '', details: '' };
                        }

                        // Make sure storageInfo is a proper object, not a string
                        if (compCopy.storageInfo === '[object Object]' || typeof compCopy.storageInfo === 'string') {
                            compCopy.storageInfo = { locationId: '', drawerId: '', cells: [] };
                        }

                        return compCopy;
                    });

                    const componentsJson = JSON.stringify(componentsToExport, null, 2); // Pretty print JSON
                    setJsonData(componentsJson);
                    setExportMessage('Components data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting components:", err);
                    setImportError(`Error exporting components: ${err.message}`);
                }
            };
            const handleExportConfig = () => {
                clearStatusMessages();
                try {
                    const configData = {
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        viewMode: viewMode,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue
                    };
                    setJsonData(JSON.stringify(configData, null, 2));
                    setExportMessage('Configuration data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting configuration:", err);
                    setImportError(`Error exporting configuration: ${err.message}`);
                }
            };

            const handleFileImport = (event, importType) => {
                clearStatusMessages();
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    setJsonData(text); // Show loaded JSON in textarea
                    try {
                        if (importType === 'components') {
                            importComponentsData(text);
                        } else if (importType === 'config') {
                            importConfigData(text);
                        }
                    } catch (err) {
                        setImportError(`Import failed: ${err.message}`);
                        // Clear textarea on failure? Maybe not, user might want to fix it.
                        // setJsonData('');
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e.target.error);
                    setImportError(`Error reading file: ${e.target.error}`);
                };
                reader.readAsText(file);

                // Reset file input to allow importing the same file again
                event.target.value = null;
            };

            const importComponentsData = (jsonDataToImport) => {
                // This function is called *after* file read is successful
                try {
                    const data = JSON.parse(jsonDataToImport);
                    if (!Array.isArray(data)) {
                        throw new Error('Imported components data must be an array.');
                    }

                    // Validate and sanitize imported data (ensure price/quantity are numbers)
                    const validatedData = data.map(comp => ({
                        ...comp,
                        id: comp.id || helpers.generateId(), // Assign ID if missing
                        price: Number(comp.price) || 0,
                        quantity: Number(comp.quantity) || 0
                    }));

                    setComponents(validatedData); // Replace existing components

                    // Update categories based on imported data (merge unique)
                    const importedCategories = [...new Set(validatedData.map(item => item.category).filter(Boolean))];
                    setCategories(prev => [...new Set([...prev, ...importedCategories])].sort());

                    setImportError(`Import successful! ${validatedData.length} components loaded.`);
                    // Optionally clear JSON area after successful import
                    // setJsonData('');
                } catch (err) {
                    console.error("Error importing components data:", err);
                    // Re-throw error to be caught by the file handler's catch block
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };

            const importConfigData = (jsonDataToImport) => {
                try {
                    const data = JSON.parse(jsonDataToImport);
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid configuration data format.');
                    }

                    let messages = [];
                    let configChanged = false;

                    // Import Categories (Merge unique)
                    if (data.categories && Array.isArray(data.categories)) {
                        const uniqueCategories = [...new Set([...categories, ...data.categories.filter(Boolean)])].sort();
                        if (uniqueCategories.length !== categories.length || !uniqueCategories.every((cat, i) => cat === categories[i])) {
                            setCategories(uniqueCategories);
                            messages.push(`${data.categories.length} categories processed.`);
                            configChanged = true;
                        } else {
                            messages.push('Categories checked (no changes).');
                        }
                    } else {
                        messages.push('No categories found in import file.');
                    }

                    // Import Low Stock Config (Overwrite)
                    if (data.lowStockConfig && typeof data.lowStockConfig === 'object') {
                        setLowStockConfig(data.lowStockConfig);
                        messages.push('Low stock config imported.');
                        configChanged = true;
                    } else {
                        messages.push('No low stock config found in import file.');
                    }

                    // Import View Mode (Overwrite)
                    if (data.viewMode && (data.viewMode === 'table' || data.viewMode === 'card')) {
                        if (viewMode !== data.viewMode) {
                            setViewMode(data.viewMode);
                            messages.push(`View mode set to '${data.viewMode}'.`);
                            configChanged = true;
                        } else {
                            messages.push('View mode checked (no change).');
                        }
                    } else {
                        messages.push('No valid view mode found in import file.');
                    }

                    // Import Currency Symbol (Overwrite)
                    if (data.currencySymbol && typeof data.currencySymbol === 'string') {
                        if (currencySymbol !== data.currencySymbol) {
                            setCurrencySymbol(data.currencySymbol);
                            messages.push(`Currency set to '${data.currencySymbol}'.`);
                            configChanged = true;
                        } else {
                            messages.push('Currency checked (no change).');
                        }
                    } else {
                        messages.push('No currency symbol found in import file.');
                    }

                    // Import Show Total Value (Overwrite)
                    if (typeof data.showTotalValue === 'boolean') {
                        if (showTotalValue !== data.showTotalValue) {
                            setShowTotalValue(data.showTotalValue);
                            messages.push(`Show total value set to ${data.showTotalValue}.`);
                            configChanged = true;
                        } else {
                            messages.push('Show total value checked (no change).');
                        }
                    } else {
                        messages.push('No total value display setting found in import file.');
                    }

                    if (configChanged) {
                        setImportError(`Configuration import finished: ${messages.join(' ')}`);
                    } else {
                        setImportError(`Configuration import checked: No changes applied. ${messages.join(' ')}`);
                    }
                    // Optionally clear JSON area after successful import
                    // setJsonData('');

                } catch (err) {
                    console.error("Error importing config data:", err);
                    // Re-throw error
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };


            const handleDownloadJson = () => {
                clearStatusMessages();
                if (!jsonData) {
                    setExportMessage('No data in the text area to download.');
                    return;
                }
                try {
                    const element = document.createElement('a');
                    const file = new Blob([jsonData], { type: 'application/json' });
                    element.href = URL.createObjectURL(file);
                    // Suggest filename based on content (simple check)
                    const suggestedFilename = jsonData.includes('"lowStockConfig":') ? 'electronics_config.json' : 'electronics_inventory.json';
                    element.download = suggestedFilename;
                    document.body.appendChild(element); // Required for Firefox
                    element.click();
                    document.body.removeChild(element);
                    URL.revokeObjectURL(element.href); // Clean up blob URL
                    setExportMessage('JSON file download initiated!');
                } catch (err) {
                    console.error("Error downloading JSON:", err);
                    setImportError(`Error creating download: ${err.message}`);
                }
            };

            const handleCopyJson = () => {
                clearStatusMessages();
                if (!jsonData) {
                    setExportMessage('No data in the text area to copy.');
                    return;
                }
                if (navigator.clipboard && window.isSecureContext) { // Use modern clipboard API if available
                    navigator.clipboard.writeText(jsonData)
                        .then(() => setExportMessage('JSON copied to clipboard!'))
                        .catch(err => {
                            console.error('Failed to copy using navigator.clipboard:', err);
                            setImportError('Failed to copy to clipboard.');
                        });
                } else { // Fallback for older browsers/insecure contexts (less reliable)
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = jsonData;
                        textArea.style.position = "fixed"; // Prevent scrolling to bottom
                        textArea.style.left = "-9999px";
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        setExportMessage('JSON copied to clipboard (using fallback method).');
                    } catch (err) {
                        console.error('Failed to copy using fallback method:', err);
                        setImportError('Failed to copy to clipboard.');
                    }
                }
            };

            // --- Settings Page Callbacks ---
            const handleAddLowStock = (category, threshold) => {
                clearStatusMessages();
                setLowStockConfig(prev => ({ ...prev, [category]: threshold }));
                setExportMessage(`Low stock threshold ${lowStockConfig[category] ? 'updated' : 'added'} for ${category}.`);
            };

            const handleRemoveLowStock = (category) => {
                clearStatusMessages();
                setLowStockConfig(prev => {
                    const updatedConfig = { ...prev };
                    delete updatedConfig[category];
                    return updatedConfig;
                });
                setExportMessage(`Low stock threshold removed for ${category}.`);
            };

            const handleEditCategory = (oldName, newName) => {
                clearStatusMessages();
                // Update category list
                setCategories(prev => prev.map(cat => cat === oldName ? newName : cat).sort());
                // Update components using the old category name
                setComponents(prev => prev.map(comp => comp.category === oldName ? { ...comp, category: newName } : comp));
                // Update low stock config if the category existed there
                if (lowStockConfig.hasOwnProperty(oldName)) {
                    setLowStockConfig(prevConfig => {
                        const newConfig = { ...prevConfig };
                        newConfig[newName] = newConfig[oldName]; // Copy threshold
                        delete newConfig[oldName]; // Remove old entry
                        return newConfig;
                    });
                }
                // If the currently selected filter was the old name, update it (or reset)
                if (selectedCategory === oldName) {
                    setSelectedCategory(newName);
                }
                setExportMessage(`Category "${oldName}" renamed to "${newName}".`);
            };

            const handleDeleteCategory = (categoryToDelete) => {
                clearStatusMessages();
                const defaultCategoryName = "Default"; // Or "Uncategorized"

                // Ensure the default category exists if we need to move items to it
                if (!categories.includes(defaultCategoryName)) {
                    setCategories(prev => [...prev, defaultCategoryName].sort());
                }

                // Remove the category from the list
                setCategories(prev => prev.filter(cat => cat !== categoryToDelete));

                // Reassign components from the deleted category to the default one
                setComponents(prev => prev.map(comp =>
                    comp.category === categoryToDelete ? { ...comp, category: defaultCategoryName } : comp
                ));

                // Remove the category from low stock config if it exists
                if (lowStockConfig.hasOwnProperty(categoryToDelete)) {
                    setLowStockConfig(prevConfig => {
                        const newConfig = { ...prevConfig };
                        delete newConfig[categoryToDelete];
                        return newConfig;
                    });
                }

                // Reset filters if the deleted category was selected
                if (selectedCategory === categoryToDelete) setSelectedCategory('all');
                // Reset low stock form if the deleted category was selected there
                // (Handled inside the SettingsView component state reset)

                setExportMessage(`Category "${categoryToDelete}" deleted. Components moved to "${defaultCategoryName}".`);
            };

            const handleAddDefaultCategory = () => {
                clearStatusMessages();
                const defaultCategoryName = "Default";
                if (!categories.includes(defaultCategoryName)) {
                    setCategories(prev => [...prev, defaultCategoryName].sort());
                    setExportMessage(`"${defaultCategoryName}" category added.`);
                } else {
                    setExportMessage(`"${defaultCategoryName}" category already exists.`);
                }
            };

            // --- Export Location & Drawers ---
            const handleExportLocations = () => {
                clearStatusMessages();
                try {
                    const locationsData = {
                        locations: locations,
                        drawers: drawers,
                        cells: cells
                    };
                    setJsonData(JSON.stringify(locationsData, null, 2));
                    setExportMessage('Locations and drawers data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting locations:", err);
                    setImportError(`Error exporting locations: ${err.message}`);
                }
            };

            const importLocationsData = (jsonDataToImport) => {
                try {
                    const data = JSON.parse(jsonDataToImport);

                    // Validate the imported data structure
                    if (!data.locations || !Array.isArray(data.locations)) {
                        throw new Error('Invalid locations data format.');
                    }

                    // Import locations
                    if (data.locations && Array.isArray(data.locations)) {
                        setLocations(data.locations);
                    }

                    // Import drawers if available
                    if (data.drawers && Array.isArray(data.drawers)) {
                        setDrawers(data.drawers);
                    }

                    // Import cells if available
                    if (data.cells && Array.isArray(data.cells)) {
                        setCells(data.cells);
                    }

                    setImportError('Locations, drawers, and cells imported successfully!');
                } catch (err) {
                    console.error("Error importing locations data:", err);
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };

            const handleLocationsFileImport = (event) => {
                clearStatusMessages();
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    setJsonData(text); // Show loaded JSON in textarea
                    try {
                        importLocationsData(text);
                    } catch (err) {
                        setImportError(`Import failed: ${err.message}`);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e.target.error);
                    setImportError(`Error reading file: ${e.target.error}`);
                };
                reader.readAsText(file);

                // Reset file input to allow importing the same file again
                event.target.value = null;
            };

            // --- Local Storage Callbacks ---
            const handleSaveComponentsLS = async () => {
                clearStatusMessages();     // ← your existing helper
                try {
                    // NEW: await the async helper
                    const ok = await storage.saveComponents(components);
                    if (ok) {
                        setExportMessage("✅ Components saved to IndexedDB.");
                    } else {
                        setImportError("❌ Component save failed.");
                    }
                } catch (err) {
                    console.error(err);
                    setImportError("❌ Component save threw an error.");
                }
            };
            const handleSaveConfig = async () => {
                clearStatusMessages();
                const currentConfig = {
                    categories,
                    viewMode,
                    lowStockConfig,
                    currencySymbol,
                    showTotalValue,
                    footprints,
                    itemsPerPage,
                    theme
                };
                try {
                    const ok = await storage.saveConfig(currentConfig);
                    if (ok) {
                        setExportMessage("✅ Config saved to LocalStorage.");
                    } else {
                        setImportError("❌ Config save failed.");
                    }
                } catch (err) {
                    console.error(err);
                    setImportError("❌ Config save threw an error.");
                }
            };

            const handleClearStorage = async () => {
                clearStatusMessages(); 

                if (window.confirm('Are you sure you want to clear ALL inventory data and settings? This action cannot be undone.')) {
                    try {
                        const cleared = await storage.clearStorage();

                        if (cleared) {
                            // Reset ALL state values to defaults
                            setComponents([]);
                            setCategories([]);
                            setLowStockConfig({});
                            setViewMode('table');
                            setSelectedCategory('all');
                            setSearchTerm('');
                            setJsonData('');
                            setImportError('');
                            setCurrencySymbol('$');
                            setShowTotalValue(false);
                            setSelectedComponents([]);
                            setLocations([]);
                            setDrawers([]);
                            setCells([]);
                            setFootprints([]);

                            setExportMessage('All storage cleared successfully! Application state reset.');
                        } else {
                            setImportError('An error occurred while trying to clear storage.');
                        }
                    } catch (err) {
                        console.error("Error clearing storage:", err);
                        setImportError(`Error clearing storage: ${err.message}`);
                    }
                }
            };

            // --- Render ---
            return (
                React.createElement('div', { className: "container mx-auto p-4 font-sans" },
                    React.createElement('h1', {
                        className: `text-3xl font-bold mb-6 text-center text-${themeColors.textPrimary}`
                    }, "Electro Manager"),
                    React.createElement('h4', {
                        className: `text font mb-6 text-center text-${themeColors.textSecondary}`
                    }, "an Electronics Inventory System | DANP-EDNA V0.1.7beta"),
                    // Navigation Tabs
                    React.createElement('div', {
                        className: `flex justify-center mb-6 border-b border-${themeColors.border} overflow-x-auto`
                    },
                        // Inventory Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('inventory');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'inventory'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Inventory List"),

                        // Locations Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('locations');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'locations'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Locations"),

                        // Drawers Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('drawers');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'drawers'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Drawers"),

                        // Settings Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('data');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'data'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Settings")
                    ),

                    // --- Conditional Page Rendering ---
                    currentPage === 'inventory' && React.createElement(InventoryView, {
                        // Pass state
                        components: components,
                        categories: categories,
                        viewMode: viewMode,
                        selectedCategory: selectedCategory,
                        searchTerm: searchTerm,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        selectedComponents: selectedComponents,
                        drawers: drawers,
                        cells: cells,
                        locations: locations,
                        footprints: footprints,
                        selectedLocation: selectedLocation,
                        itemsPerPage: itemsPerPage,

                        // Pass callbacks
                        onAddComponent: handleAddComponent,
                        onEditComponent: handleEditComponent,
                        onDeleteComponent: handleDeleteComponent,
                        onUpdateQuantity: handleUpdateQuantity,
                        onToggleSelect: handleToggleSelect,
                        onToggleSelectAll: handleToggleSelectAll,
                        onBulkEdit: handleBulkEdit,
                        onBulkDelete: handleBulkDelete,
                        onChangeViewMode: setViewMode,
                        onChangeCategoryFilter: setSelectedCategory,
                        onChangeSearchTerm: setSearchTerm,
                        onChangeLocationFilter: setSelectedLocation,
                        onToggleFavorite: handleToggleFavorite,
                        onItemsPerPageChange: handleItemsPerPageChange,
                    }),

                    currentPage === 'data' && React.createElement(SettingsView, {
                        // Pass state
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        jsonData: jsonData,
                        importError: importError,
                        exportMessage: exportMessage,
                        footprints: footprints,
                        locations: locations,
                        components: components,
                        theme: theme, // Pass theme state
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        // Pass callbacks
                        onExportComponents: handleExportComponents,
                        onExportConfig: handleExportConfig,
                        onImportComponentsFile: (e) => handleFileImport(e, 'components'),
                        onImportConfigFile: (e) => handleFileImport(e, 'config'),
                        onDownloadJson: handleDownloadJson,
                        onExportLocations: handleExportLocations,
                        onImportLocationsFile: handleLocationsFileImport,
                        onCopyJson: handleCopyJson,
                        onClearJsonArea: () => { setJsonData(''); clearStatusMessages(); },
                        onChangeCurrency: (e) => { setCurrencySymbol(e.target.value); clearStatusMessages(); },
                        onChangeShowTotalValue: (e) => { setShowTotalValue(e.target.checked); clearStatusMessages(); },
                        onAddLowStock: handleAddLowStock,
                        onRemoveLowStock: handleRemoveLowStock,
                        onEditCategory: handleEditCategory,
                        onDeleteCategory: handleDeleteCategory,
                        onAddDefaultCategory: handleAddDefaultCategory,
                        onSaveComponentsLS: handleSaveComponentsLS,
                        onSaveConfig: handleSaveConfig,
                        onClearStorage: handleClearStorage,
                        onAddFootprint: handleAddFootprint,
                        onEditFootprint: handleEditFootprint,
                        onDeleteFootprint: handleDeleteFootprint,
                        onEditComponent: handleEditComponent,
                        onRestoreDefaultFootprints: handleRestoreDefaultFootprints,
                        onChangeTheme: handleThemeChange, // Add theme change handler
                    }),

                    currentPage === 'locations' && React.createElement(LocationPage, {
                        locations: locations,
                        components: components,
                        drawers: drawers,
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: handleNavigateToDrawer // Add this prop
                    }),

                    // Add to the conditional page rendering section
                    currentPage === 'drawers' && React.createElement(DrawerPage, {
                        locations: locations,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        components: components,
                        initialDrawerId: viewingDrawerId, // Add this prop
                        onAddDrawer: handleAddDrawer,
                        onEditDrawer: handleEditDrawer,
                        onDeleteDrawer: handleDeleteDrawer,
                        onAddCell: handleAddCell,
                        onEditCell: handleEditCell,
                        onDeleteCell: handleDeleteCell,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: (drawerId) => setViewingDrawerId(drawerId),
                    }),

                    // --- Modals (Rendered conditionally based on state) ---
                    showForm && React.createElement(ComponentForm, {
                        componentData: editComponentData,
                        categories: categories,
                        footprints: footprints,
                        locations: locations,
                        drawers: drawers, // Add drawers
                        cells: cells,    // Add cells
                        currencySymbol: currencySymbol,
                        onSave: handleSaveComponent,
                        onCancel: () => { setShowForm(false); setEditComponentData(null); },
                        isEditMode: !!editComponentData?.id
                    }),

                    // Update this code in the render part of index.html where BulkEditForm is used

                    showBulkEditForm && React.createElement(BulkEditForm, {
                        categories: categories,
                        commonFootprints: footprints,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        selectedCount: selectedComponents.length,
                        onApply: handleApplyBulkEdit,
                        onCancel: () => setShowBulkEditForm(false)
                    })

                ) // End Main Container Div
            ); // End Main Return
        }; // End ElectronicsInventory Component

        // --- Render the Application ---
        // Ensure the root element exists before rendering
        const rootElement = document.getElementById('root');
        if (rootElement) {
            // Use the new createRoot API for React 18
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(ElectronicsInventory));
        } else {
            console.error("Root element (#root) not found in the DOM.");
        }
    </script>
</body>

</html>