<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electronics Inventory (Modular)</title>
    <!--
    <script src="js/external/tailwind.js"></script>
    <script src="js/external/react18.development.js"></script>
    <script src="js/external/react-dom18.development.js"></script>
    <script src="js/external/babel.min.js"></script>
    -->
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/utils/ui-constants.js"></script>

    <script src="js/components/ComponentForm.js"></script>
    <script src="js/components/BulkEditForm.js"></script>
    <script src="js/components/InventoryView.js"></script>
    <script src="js/components/SettingsView.js"></script>
    <script src="js/components/FootprintManager.js"></script>
    <script src="js/components/LocationManager.js"></script>
    <script src="js/components/LocationPage.js"></script>
    <script src="js/components/DrawerManager.js"></script>
    <script src="js/components/DrawerView.js"></script>
    <script src="js/components/DrawerPage.js"></script>

</head>

<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        // Ensure App namespace and sub-namespaces exist
        window.App = window.App || {};
        window.App.utils = window.App.utils || {};
        window.App.components = window.App.components || {};

        // Destructure React hooks and loaded components/utils for easier use
        const { useState, useEffect, useCallback } = React;
        const { helpers } = window.App.utils;
        const { storage } = window.App.utils;
        const { ComponentForm, BulkEditForm, InventoryView, SettingsView, DrawerPage, LocationPage } = window.App.components;

        // --- Main Application Component ---
        const ElectronicsInventory = () => {
            // --- State Variables ---
            const [components, setComponents] = useState([]);
            const [categories, setCategories] = useState([]);
            const [currentPage, setCurrentPage] = useState('inventory'); // 'inventory', 'locations', 'data', or 'drawers'
            const [viewMode, setViewMode] = useState('table'); // 'table' or 'card'
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            const [showForm, setShowForm] = useState(false); // For add/edit component modal
            const [editComponentData, setEditComponentData] = useState(null); // Data for the component being edited/added
            const [jsonData, setJsonData] = useState(''); // For import/export text area
            const [importError, setImportError] = useState(''); // Message after import attempt
            const [exportMessage, setExportMessage] = useState(''); // Message after export/save attempt
            const [lowStockConfig, setLowStockConfig] = useState({}); // { category: threshold }
            const [currencySymbol, setCurrencySymbol] = useState('$');
            const [showTotalValue, setShowTotalValue] = useState(false);
            const [selectedComponents, setSelectedComponents] = useState([]); // Array of selected component IDs for bulk actions
            const [showBulkEditForm, setShowBulkEditForm] = useState(false);
            const [locations, setLocations] = useState([]);
            const [selectedLocation, setSelectedLocation] = useState('all');
            const [footprints, setFootprints] = useState([]);
            const [drawers, setDrawers] = useState([]);
            const [cells, setCells] = useState([]);
            const [viewingDrawerId, setViewingDrawerId] = useState(null);
            //const [showAddDrawerForm, setShowAddDrawerForm] = useState(false);

            // --- Effects ---

            // Load data from localStorage on initial render
            useEffect(() => {
                console.log("Initial load effect running...");
                setComponents(storage.loadComponents());
                const config = storage.loadConfig();
                setCategories(config.categories);
                setViewMode(config.viewMode);
                setLowStockConfig(config.lowStockConfig);
                setCurrencySymbol(config.currencySymbol);
                setShowTotalValue(config.showTotalValue);
                setFootprints(config.footprints || []);
                setLocations(storage.loadLocations() || []);

                // Load drawers from localStorage
                setDrawers(storage.loadDrawers() || []);

                // Load cells from localStorage 
                setCells(storage.loadCells() || []);

                // Fallback: If categories are empty but components exist, derive from components
                if (config.categories.length === 0) {
                    const loadedComponents = storage.loadComponents(); // Load again or use already loaded
                    if (loadedComponents.length > 0) {
                        const derivedCategories = [...new Set(loadedComponents.map(item => item.category).filter(Boolean))];
                        if (derivedCategories.length > 0) {
                            setCategories(derivedCategories);
                            // Optionally save derived categories back to storage
                            // storage.saveConfig({ ...config, categories: derivedCategories });
                            console.log("Derived categories from existing components.");
                        }
                    }
                }
                console.log("Initial load complete.");
            }, []); // Runs only once on mount

            useEffect(() => {
                let cells = storage.loadCells() || [];

                // Set default availability for cells that don't have it set
                cells = cells.map(cell => ({
                    ...cell,
                    available: cell.available !== undefined ? cell.available : true
                }));

                setCells(cells);
            }, []);

            useEffect(() => {
                storage.saveDrawers(drawers);
            }, [drawers]);

            useEffect(() => {
                storage.saveCells(cells);
            }, [cells]);



            // Save components to localStorage whenever they change
            // Use useCallback for stability if passed as dependency elsewhere, though not strictly needed here
            const saveComponentsCallback = useCallback(() => {
                storage.saveComponents(components);
            }, [components]);


            useEffect(() => {
                // Save components whenever the list changes
                saveComponentsCallback();
            }, [components, saveComponentsCallback]);

            // Save configuration changes to localStorage
            const saveConfigCallback = useCallback(() => {
                storage.saveConfig({
                    categories,
                    viewMode,
                    lowStockConfig,
                    currencySymbol,
                    showTotalValue,
                    footprints // Add this line
                });
            }, [categories, viewMode, lowStockConfig, currencySymbol, showTotalValue, footprints]);

            useEffect(() => {
                saveConfigCallback();
            }, [categories, viewMode, lowStockConfig, currencySymbol, showTotalValue, footprints, saveConfigCallback]);
            // Dependency array includes the callback itself

            // --- Helper Functions / Callbacks for Child Components ---

            // Clear status messages (import/export)
            const clearStatusMessages = () => {
                setImportError('');
                setExportMessage('');
            };

            // --- Component CRUD Callbacks ---
            const handleAddComponent = () => {
                clearStatusMessages();
                // Prepare initial data for the form (empty component)
                setEditComponentData({
                    id: '', name: '', category: '', customCategory: '', type: '', quantity: 0, price: 0,
                    footprint: '', customFootprint: '', parameters: '', info: '', datasheets: '', image: ''
                });
                setShowForm(true);
            };

            const handleEditComponent = (componentToEdit) => {
                clearStatusMessages();

                // Create a deep copy of the component
                const cleanComponent = { ...componentToEdit };

                // Ensure locationInfo is a proper object
                if (!cleanComponent.locationInfo ||
                    typeof cleanComponent.locationInfo === 'string' ||
                    cleanComponent.locationInfo === '[object Object]') {
                    cleanComponent.locationInfo = { locationId: '', details: '' };
                }

                // Ensure storageInfo is a proper object
                if (!cleanComponent.storageInfo ||
                    typeof cleanComponent.storageInfo === 'string' ||
                    cleanComponent.storageInfo === '[object Object]') {
                    cleanComponent.storageInfo = { locationId: '', drawerId: '', cells: [] };
                } else {
                    // Handle partial storageInfo objects that might be missing the cells array
                    cleanComponent.storageInfo = {
                        locationId: cleanComponent.storageInfo.locationId || '',
                        drawerId: cleanComponent.storageInfo.drawerId || '',
                        cells: Array.isArray(cleanComponent.storageInfo.cells)
                            ? cleanComponent.storageInfo.cells
                            : []
                    };

                    // Handle backward compatibility - if cellId exists but cells array doesn't include it
                    if (cleanComponent.storageInfo.cellId &&
                        !cleanComponent.storageInfo.cells.includes(cleanComponent.storageInfo.cellId)) {
                        cleanComponent.storageInfo.cells.push(cleanComponent.storageInfo.cellId);
                    }
                }

                // Ensure flag fields exist
                cleanComponent.favorite = cleanComponent.favorite || false;
                cleanComponent.bookmark = cleanComponent.bookmark || false;
                cleanComponent.star = cleanComponent.star || false;

                // Determine if the footprint is custom
                const isCustomFootprint = cleanComponent.footprint &&
                    !footprints.includes(cleanComponent.footprint);

                // Prepare data for the form, formatting parameters
                setEditComponentData({
                    ...cleanComponent,
                    price: Number(cleanComponent.price) || 0, // Ensure price is number
                    quantity: Number(cleanComponent.quantity) || 0, // Ensure quantity is number
                    customCategory: '', // Reset custom field initially
                    // Set footprint dropdown value and custom input value
                    footprint: isCustomFootprint ? '__custom__' : (cleanComponent.footprint || ''),
                    customFootprint: isCustomFootprint ? cleanComponent.footprint : '',
                    // Format additional parameters for the textarea
                    parameters: helpers.formatParametersForEdit(cleanComponent)
                });
                setShowForm(true);
            };
            // Update to handleSaveComponent
            const handleSaveComponent = (componentDataFromForm) => {
                clearStatusMessages();
                let categoryToSave = componentDataFromForm.category;
                let footprintToSave = componentDataFromForm.footprint;
                let newCategoryAdded = false;

                // Handle custom category
                if (componentDataFromForm.category === '__custom__' && componentDataFromForm.customCategory) {
                    categoryToSave = componentDataFromForm.customCategory.trim();
                    if (categoryToSave && !categories.includes(categoryToSave)) {
                        setCategories(prev => [...prev, categoryToSave].sort());
                        newCategoryAdded = true; // Mark that we might need to revert if save fails
                    } else if (!categoryToSave) {
                        // Handle case where custom is selected but input is empty
                        alert("New category name cannot be empty.");
                        return; // Prevent saving
                    }
                }

                // Handle custom footprint
                if (componentDataFromForm.footprint === '__custom__' && componentDataFromForm.customFootprint) {
                    footprintToSave = componentDataFromForm.customFootprint.trim();
                    if (!footprintToSave) {
                        alert("Custom footprint name cannot be empty.");
                        if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave)); // Revert category add if needed
                        return; // Prevent saving
                    }
                } else if (componentDataFromForm.footprint === '__custom__') {
                    // Custom selected but input empty - treat as no footprint selected
                    footprintToSave = '';
                }

                // Basic validation
                if (!componentDataFromForm.name || !categoryToSave) {
                    alert("Component Name and Category are required.");
                    // Revert category addition if validation fails
                    if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave));
                    return;
                }

                // Ensure locationInfo is properly formatted
                let locationInfo = componentDataFromForm.locationInfo;
                if (!locationInfo || typeof locationInfo === 'string' || locationInfo === '[object Object]') {
                    locationInfo = { locationId: '', details: '' };
                }

                // Process the storage information
                let storageInfo = componentDataFromForm.storageInfo;
                if (!storageInfo || typeof storageInfo === 'string' || storageInfo === '[object Object]') {
                    storageInfo = { locationId: '', drawerId: '', cells: [] };
                }

                // Ensure we store storage information properly
                const finalStorageInfo = {
                    locationId: storageInfo.locationId || '',
                    drawerId: storageInfo.drawerId || '',
                    cells: Array.isArray(storageInfo.cells) ? storageInfo.cells : []
                };

                // For backward compatibility with older components
                if (storageInfo.cellId && !finalStorageInfo.cells.includes(storageInfo.cellId)) {
                    finalStorageInfo.cells.push(storageInfo.cellId);
                }

                // Prepare the final component object
                const finalComponent = {
                    // Core fields
                    id: componentDataFromForm.id || helpers.generateId(), // Generate ID if new
                    name: componentDataFromForm.name.trim(),
                    favorite: componentDataFromForm.favorite || false,
                    bookmark: componentDataFromForm.bookmark || false,
                    star: componentDataFromForm.star || false,
                    category: categoryToSave,
                    type: componentDataFromForm.type.trim(),
                    quantity: parseInt(componentDataFromForm.quantity, 10) || 0,
                    price: parseFloat(componentDataFromForm.price) || 0,
                    footprint: footprintToSave,
                    info: (componentDataFromForm.info || '').trim(),
                    datasheets: componentDataFromForm.datasheets.trim(),
                    image: componentDataFromForm.image.trim(),
                    // Add location and storage information
                    locationInfo: locationInfo,
                    storageInfo: finalStorageInfo
                };

                // Add additional parameters, but filter out any special fields that might have been incorrectly included
                const additionalParams = helpers.parseParameters(componentDataFromForm.parameters);
                // Remove any properties that would conflict with core properties
                Object.keys(additionalParams).forEach(key => {
                    if (finalComponent.hasOwnProperty(key)) {
                        console.warn(`Parameter '${key}' conflicts with a core property and will be ignored.`);
                        delete additionalParams[key];
                    }
                });
                // Now add the filtered parameters
                Object.assign(finalComponent, additionalParams);

                // Update state: either replace existing or add new
                if (componentDataFromForm.id) { // Editing existing component
                    setComponents(prev => prev.map(comp =>
                        comp.id === componentDataFromForm.id ? finalComponent : comp
                    ));
                } else { // Adding new component
                    setComponents(prev => [...prev, finalComponent]);
                }

                // Close form and reset edit state
                setShowForm(false);
                setEditComponentData(null);
                setExportMessage(componentDataFromForm.id ? 'Component updated.' : 'Component added.');
            };

            const handleDeleteComponent = (idToDelete) => {
                clearStatusMessages();
                if (window.confirm('Are you sure you want to delete this component? This action cannot be undone.')) {
                    setComponents(prev => prev.filter(comp => comp.id !== idToDelete));
                    // Also remove from selection if it was selected
                    setSelectedComponents(prev => prev.filter(selId => selId !== idToDelete));
                    setExportMessage('Component deleted.');
                }
            };

            const handleUpdateQuantity = (id, delta) => {
                // No need to clear messages for this frequent action
                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        const currentQuantity = Number(comp.quantity) || 0;
                        // Prevent quantity from going below zero
                        return { ...comp, quantity: Math.max(0, currentQuantity + delta) };
                    }
                    return comp;
                }));
            };

            const handleToggleFavorite = (id, property) => {
                if (!['favorite', 'bookmark', 'star'].includes(property)) return;

                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        // Toggle the property
                        return {
                            ...comp,
                            [property]: !(comp[property] || false)
                        };
                    }
                    return comp;
                }));
            };

            useEffect(() => {
                storage.saveLocations(locations);
            }, [locations]);



            // --- Bulk Action Callbacks ---
            const handleToggleSelect = (id) => {
                setSelectedComponents(prev =>
                    prev.includes(id) ? prev.filter(selId => selId !== id) : [...prev, id]
                );
            };

            const handleToggleSelectAll = () => {
                // Filter components based on current view filters *before* selecting all
                const currentlyFilteredIds = components
                    .filter(component => {
                        const matchesCategory = selectedCategory === 'all' || component.category === selectedCategory;
                        const lowerSearchTerm = searchTerm.toLowerCase();
                        const matchesSearch = !searchTerm ||
                            (component.name && component.name.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.type && component.type.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.category && component.category.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.info && component.info.toLowerCase().includes(lowerSearchTerm));
                        return matchesCategory && matchesSearch;
                    })
                    .map(comp => comp.id);

                if (selectedComponents.length === currentlyFilteredIds.length && currentlyFilteredIds.length > 0) {
                    // If all filtered are selected, deselect all
                    setSelectedComponents([]);
                } else {
                    // Otherwise, select all filtered
                    setSelectedComponents(currentlyFilteredIds);
                }
            };

            const handleBulkEdit = () => {
                clearStatusMessages();
                if (selectedComponents.length === 0) return;
                setShowBulkEditForm(true); // Open the bulk edit modal
            };

            const handleApplyBulkEdit = (bulkEditData) => {
                clearStatusMessages();
                let categoryToApply = bulkEditData.category;
                let footprintToApply = bulkEditData.footprint;
                let newCategoryAdded = false;

                // Handle custom category from bulk edit
                if (bulkEditData.category === '__custom__' && bulkEditData.customCategory) {
                    categoryToApply = bulkEditData.customCategory.trim();
                    if (categoryToApply && !categories.includes(categoryToApply)) {
                        setCategories(prev => [...prev, categoryToApply].sort());
                        newCategoryAdded = true;
                    } else if (!categoryToApply) {
                        // Don't apply if custom is selected but name is empty
                        categoryToApply = ''; // Effectively means "keep existing"
                    }
                }

                // Handle custom footprint from bulk edit
                if (bulkEditData.footprint === '__custom__' && bulkEditData.customFootprint) {
                    footprintToApply = bulkEditData.customFootprint.trim();
                    if (!footprintToApply) footprintToApply = ''; // Treat empty custom as no change
                } else if (bulkEditData.footprint === '__custom__') {
                    footprintToApply = ''; // Treat empty custom as no change
                }

                setComponents(prevComponents => prevComponents.map(comp => {
                    // Apply changes only to selected components
                    if (selectedComponents.includes(comp.id)) {
                        const updates = {};

                        // Apply Category (if specified and valid)
                        if (categoryToApply && categoryToApply !== '__custom__') {
                            updates.category = categoryToApply;
                        }

                        // Apply Type (if specified)
                        if (bulkEditData.type.trim()) {
                            updates.type = bulkEditData.type.trim();
                        }

                        // Apply Footprint (if specified and valid)
                        if (footprintToApply && footprintToApply !== '__custom__') {
                            updates.footprint = footprintToApply;
                        }

                        // Apply Quantity Adjustment
                        if (bulkEditData.quantity !== '' && !isNaN(bulkEditData.quantity)) {
                            const changeValue = parseInt(bulkEditData.quantity, 10) || 0;
                            const currentQuantity = Number(comp.quantity) || 0;
                            if (bulkEditData.quantityAction === 'set') {
                                updates.quantity = Math.max(0, changeValue);
                            } else if (bulkEditData.quantityAction === 'increment') {
                                updates.quantity = currentQuantity + changeValue;
                            } else if (bulkEditData.quantityAction === 'decrement') {
                                updates.quantity = Math.max(0, currentQuantity - changeValue);
                            }
                        }

                        // Apply Price Adjustment
                        if (bulkEditData.price !== '' && !isNaN(bulkEditData.price)) {
                            const priceChangeValue = parseFloat(bulkEditData.price) || 0;
                            const currentPrice = Number(comp.price) || 0;
                            if (bulkEditData.priceAction === 'set') {
                                updates.price = Math.max(0, priceChangeValue); // Ensure non-negative
                            } else if (bulkEditData.priceAction === 'increase') {
                                updates.price = Math.max(0, currentPrice + priceChangeValue);
                            } else if (bulkEditData.priceAction === 'decrease') {
                                updates.price = Math.max(0, currentPrice - priceChangeValue);
                            }
                        }

                        // Apply Favorite status (if defined)
                        if (bulkEditData.favorite !== null) {
                            updates.favorite = bulkEditData.favorite;
                        }

                        // Apply Bookmark status (if defined)
                        if (bulkEditData.bookmark !== null) {
                            updates.bookmark = bulkEditData.bookmark;
                        }

                        // Apply Star status (if defined)
                        if (bulkEditData.star !== null) {
                            updates.star = bulkEditData.star;
                        }

                        // --- Apply Location Updates ---

                        // Initialize locationInfo if needed
                        if (!comp.locationInfo || typeof comp.locationInfo === 'string' || comp.locationInfo === '[object Object]') {
                            comp.locationInfo = { locationId: '', details: '' };
                        }

                        // Handle location changes
                        if (bulkEditData.locationAction === 'clear') {
                            // Clear location information
                            updates.locationInfo = { locationId: '', details: '' };
                        } else if (bulkEditData.locationAction === 'set' && bulkEditData.locationId) {
                            // Set to a new location
                            updates.locationInfo = {
                                locationId: bulkEditData.locationId,
                                details: bulkEditData.locationDetails || ''
                            };
                        }

                        // --- Apply Storage/Drawer/Cell Updates ---

                        // Initialize storageInfo if needed
                        if (!comp.storageInfo || typeof comp.storageInfo === 'string' || comp.storageInfo === '[object Object]') {
                            comp.storageInfo = { locationId: '', drawerId: '', cells: [] };
                        } else if (!Array.isArray(comp.storageInfo.cells)) {
                            comp.storageInfo.cells = [];
                        }

                        // Handle storage actions
                        if (bulkEditData.storageAction === 'clear') {
                            // Clear drawer assignment
                            updates.storageInfo = {
                                locationId: '',
                                drawerId: '',
                                cells: []
                            };
                        } else if (bulkEditData.storageAction === 'set') {
                            // Set to new drawer and cells
                            if (bulkEditData.storageLocationId) {
                                const newStorageInfo = {
                                    locationId: bulkEditData.storageLocationId,
                                    drawerId: bulkEditData.drawerId || '',
                                    cells: bulkEditData.drawerId ? bulkEditData.selectedCells : []
                                };
                                updates.storageInfo = newStorageInfo;
                            }
                        }

                        // Return the component with applied updates
                        return { ...comp, ...updates };
                    }
                    // Return unchanged component if not selected
                    return comp;
                }));

                // Close the bulk edit form and clear selection
                setShowBulkEditForm(false);
                setSelectedComponents([]);
                setExportMessage(`${selectedComponents.length} component(s) updated.`);
            };
            const handleBulkDelete = () => {
                clearStatusMessages();
                if (selectedComponents.length === 0) return;
                if (window.confirm(`Are you sure you want to delete ${selectedComponents.length} selected component(s)? This action cannot be undone.`)) {
                    setComponents(prev => prev.filter(comp => !selectedComponents.includes(comp.id)));
                    const deletedCount = selectedComponents.length; // Store count before clearing
                    setSelectedComponents([]); // Clear selection
                    setExportMessage(`${deletedCount} component(s) deleted.`);
                }
            };

            //-- Location Management--
            const handleAddLocation = (newLocation) => {
                clearStatusMessages();
                setLocations(prev => [...prev, newLocation]);
                setExportMessage('Location added.');
            };

            const handleEditLocation = (locationId, updatedLocation) => {
                clearStatusMessages();
                setLocations(prev => prev.map(loc =>
                    loc.id === locationId ? updatedLocation : loc
                ));
                setExportMessage('Location updated.');
            };

            const handleDeleteLocation = (locationId) => {
                clearStatusMessages();

                // Check if any components are assigned to this location
                const assignedComponents = components.filter(comp =>
                    comp.locationInfo && comp.locationInfo.locationId === locationId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This location has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the location from these components. Continue?`
                    : 'Are you sure you want to delete this location?';

                if (window.confirm(message)) {
                    // Clear location from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.locationInfo && comp.locationInfo.locationId === locationId) {
                                // Return component with cleared location
                                return {
                                    ...comp,
                                    locationInfo: null
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the location
                    setLocations(prev => prev.filter(loc => loc.id !== locationId));
                    setExportMessage(`Location deleted. ${assignedComponents.length > 0 ? `Location cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            //--Drawer Management

            // Add handlers for drawers
            const handleAddDrawer = (newDrawer) => {
                clearStatusMessages();
                setDrawers(prev => [...prev, newDrawer]);
                setExportMessage('Drawer added.');
            };

            const handleEditDrawer = (drawerId, updatedDrawer) => {
                clearStatusMessages();
                setDrawers(prev => prev.map(drawer =>
                    drawer.id === drawerId ? updatedDrawer : drawer
                ));
                setExportMessage('Drawer updated.');
            };

            const handleDeleteDrawer = (drawerId) => {
                clearStatusMessages();

                // Check if any components are assigned to this drawer
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.drawerId === drawerId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This drawer has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the drawer from these components. Continue?`
                    : 'Are you sure you want to delete this drawer?';

                if (window.confirm(message)) {
                    // Clear drawer from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.drawerId === drawerId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        drawerId: '',
                                        cellId: ''  // Also clear cell if drawer is deleted
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Also delete all cells belonging to this drawer
                    setCells(prev => prev.filter(cell => cell.drawerId !== drawerId));

                    // Remove the drawer
                    setDrawers(prev => prev.filter(drawer => drawer.id !== drawerId));
                    setExportMessage(`Drawer deleted. ${assignedComponents.length > 0 ? `Drawer cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            // Add handlers for cells
            const handleAddCell = (newCell) => {
                clearStatusMessages();
                setCells(prev => [...prev, newCell]);
                setExportMessage('Cell added.');
            };

            const handleEditCell = (cellId, updatedCell) => {
                clearStatusMessages();
                setCells(prev => prev.map(cell =>
                    cell.id === cellId ? updatedCell : cell
                ));
                //available: existingCell.available !== undefined ? existingCell.available : true
                setExportMessage('Cell updated.');
            };

            const handleDeleteCell = (cellId) => {
                clearStatusMessages();

                // Check if any components are assigned to this cell
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.cellId === cellId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This cell has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the cell from these components. Continue?`
                    : 'Are you sure you want to delete this cell?';

                if (window.confirm(message)) {
                    // Clear cell from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.cellId === cellId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        cellId: ''  // Clear cell but keep drawer
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the cell
                    setCells(prev => prev.filter(cell => cell.id !== cellId));
                    setExportMessage(`Cell deleted. ${assignedComponents.length > 0 ? `Cell cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            const handleNavigateToDrawer = (drawerId) => {
                setCurrentPage('drawers'); // Change to drawer page
                // You need to expose this state variable to the DrawerPage
                setViewingDrawerId(drawerId);
            };

            //-- Footprint Management---
            const handleAddFootprint = (newFootprint) => {
                clearStatusMessages();
                const trimmedFootprint = newFootprint.trim();
                if (!trimmedFootprint) {
                    setExportMessage('Footprint name cannot be empty.');
                    return;
                }
                if (footprints.includes(trimmedFootprint)) {
                    setExportMessage(`Footprint "${trimmedFootprint}" already exists.`);
                    return;
                }

                setFootprints(prev => [...prev, trimmedFootprint].sort());
                setExportMessage(`Footprint "${trimmedFootprint}" added.`);
            };

            const handleEditFootprint = (oldFootprint, newFootprint) => {
                clearStatusMessages();
                const trimmedNewFootprint = newFootprint.trim();
                if (!trimmedNewFootprint) {
                    setExportMessage('Footprint name cannot be empty.');
                    return;
                }
                if (footprints.includes(trimmedNewFootprint)) {
                    setExportMessage(`Footprint "${trimmedNewFootprint}" already exists.`);
                    return;
                }

                // Update footprint list
                setFootprints(prev => prev.map(fp => fp === oldFootprint ? trimmedNewFootprint : fp).sort());

                // Update components using the old footprint
                setComponents(prev => prev.map(comp =>
                    comp.footprint === oldFootprint ? { ...comp, footprint: trimmedNewFootprint } : comp
                ));

                setExportMessage(`Footprint "${oldFootprint}" renamed to "${trimmedNewFootprint}".`);
            };

            const handleDeleteFootprint = (footprintToDelete) => {
                clearStatusMessages();
                // Check if any components are using this footprint
                const componentsUsingFootprint = components.filter(comp => comp.footprint === footprintToDelete);

                if (componentsUsingFootprint.length > 0) {
                    const confirmMessage = `${componentsUsingFootprint.length} component(s) are using this footprint. Removing it will clear the footprint from these components. Continue?`;
                    if (!window.confirm(confirmMessage)) {
                        return;
                    }

                    // Clear footprint from components
                    setComponents(prev => prev.map(comp =>
                        comp.footprint === footprintToDelete ? { ...comp, footprint: '' } : comp
                    ));
                }

                // Remove the footprint from the list
                setFootprints(prev => prev.filter(fp => fp !== footprintToDelete));
                setExportMessage(`Footprint "${footprintToDelete}" deleted.`);
            };

            const handleRestoreDefaultFootprints = () => {
                clearStatusMessages();
                // Define the default footprints list here
                const defaultFootprints = [
                    "0603", "0805", "1206", "1210", "0402", "0201", "2512",
                    "SOT-23", "SOT-223", "SOT-89", "SOT-143",
                    "SOIC-8", "SOIC-16", "TSSOP-16", "TSSOP-20",
                    "DIP-8", "DIP-14", "DIP-16", "DIP-20", "DIP-28",
                    "QFP-32", "QFP-44", "QFP-64", "QFP-100",
                    "QFN-16", "QFN-20", "QFN-24", "QFN-32",
                    "TO-92", "TO-220", "TO-247", "TO-263", "TO-252"
                ];

                if (window.confirm('This will add common electronic component footprints to your list. Continue?')) {
                    // Merge current footprints with defaults to avoid duplicates
                    const merged = [...new Set([...defaultFootprints, ...footprints])].sort();
                    setFootprints(merged);
                    setExportMessage('Common footprints added to your list.');
                }
            };

            // --- Data Management Callbacks (Import/Export) ---
            const handleExportComponents = () => {
                clearStatusMessages();
                try {
                    // Make sure all objects are properly serialized as JSON objects
                    // Deep copy the components to avoid modifying the original objects
                    const componentsToExport = components.map(comp => {
                        // Create a deep copy of the component
                        const compCopy = { ...comp };

                        // Make sure locationInfo is a proper object, not a string
                        if (compCopy.locationInfo === '[object Object]' || typeof compCopy.locationInfo === 'string') {
                            compCopy.locationInfo = { locationId: '', details: '' };
                        }

                        // Make sure storageInfo is a proper object, not a string
                        if (compCopy.storageInfo === '[object Object]' || typeof compCopy.storageInfo === 'string') {
                            compCopy.storageInfo = { locationId: '', drawerId: '', cells: [] };
                        }

                        return compCopy;
                    });

                    const componentsJson = JSON.stringify(componentsToExport, null, 2); // Pretty print JSON
                    setJsonData(componentsJson);
                    setExportMessage('Components data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting components:", err);
                    setImportError(`Error exporting components: ${err.message}`);
                }
            };
            const handleExportConfig = () => {
                clearStatusMessages();
                try {
                    const configData = {
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        viewMode: viewMode,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue
                    };
                    setJsonData(JSON.stringify(configData, null, 2));
                    setExportMessage('Configuration data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting configuration:", err);
                    setImportError(`Error exporting configuration: ${err.message}`);
                }
            };

            const handleFileImport = (event, importType) => {
                clearStatusMessages();
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    setJsonData(text); // Show loaded JSON in textarea
                    try {
                        if (importType === 'components') {
                            importComponentsData(text);
                        } else if (importType === 'config') {
                            importConfigData(text);
                        }
                    } catch (err) {
                        setImportError(`Import failed: ${err.message}`);
                        // Clear textarea on failure? Maybe not, user might want to fix it.
                        // setJsonData('');
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e.target.error);
                    setImportError(`Error reading file: ${e.target.error}`);
                };
                reader.readAsText(file);

                // Reset file input to allow importing the same file again
                event.target.value = null;
            };

            const importComponentsData = (jsonDataToImport) => {
                // This function is called *after* file read is successful
                try {
                    const data = JSON.parse(jsonDataToImport);
                    if (!Array.isArray(data)) {
                        throw new Error('Imported components data must be an array.');
                    }

                    // Validate and sanitize imported data (ensure price/quantity are numbers)
                    const validatedData = data.map(comp => ({
                        ...comp,
                        id: comp.id || helpers.generateId(), // Assign ID if missing
                        price: Number(comp.price) || 0,
                        quantity: Number(comp.quantity) || 0
                    }));

                    setComponents(validatedData); // Replace existing components

                    // Update categories based on imported data (merge unique)
                    const importedCategories = [...new Set(validatedData.map(item => item.category).filter(Boolean))];
                    setCategories(prev => [...new Set([...prev, ...importedCategories])].sort());

                    setImportError(`Import successful! ${validatedData.length} components loaded.`);
                    // Optionally clear JSON area after successful import
                    // setJsonData('');
                } catch (err) {
                    console.error("Error importing components data:", err);
                    // Re-throw error to be caught by the file handler's catch block
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };

            const importConfigData = (jsonDataToImport) => {
                try {
                    const data = JSON.parse(jsonDataToImport);
                    if (!data || typeof data !== 'object') {
                        throw new Error('Invalid configuration data format.');
                    }

                    let messages = [];
                    let configChanged = false;

                    // Import Categories (Merge unique)
                    if (data.categories && Array.isArray(data.categories)) {
                        const uniqueCategories = [...new Set([...categories, ...data.categories.filter(Boolean)])].sort();
                        if (uniqueCategories.length !== categories.length || !uniqueCategories.every((cat, i) => cat === categories[i])) {
                            setCategories(uniqueCategories);
                            messages.push(`${data.categories.length} categories processed.`);
                            configChanged = true;
                        } else {
                            messages.push('Categories checked (no changes).');
                        }
                    } else {
                        messages.push('No categories found in import file.');
                    }

                    // Import Low Stock Config (Overwrite)
                    if (data.lowStockConfig && typeof data.lowStockConfig === 'object') {
                        setLowStockConfig(data.lowStockConfig);
                        messages.push('Low stock config imported.');
                        configChanged = true;
                    } else {
                        messages.push('No low stock config found in import file.');
                    }

                    // Import View Mode (Overwrite)
                    if (data.viewMode && (data.viewMode === 'table' || data.viewMode === 'card')) {
                        if (viewMode !== data.viewMode) {
                            setViewMode(data.viewMode);
                            messages.push(`View mode set to '${data.viewMode}'.`);
                            configChanged = true;
                        } else {
                            messages.push('View mode checked (no change).');
                        }
                    } else {
                        messages.push('No valid view mode found in import file.');
                    }

                    // Import Currency Symbol (Overwrite)
                    if (data.currencySymbol && typeof data.currencySymbol === 'string') {
                        if (currencySymbol !== data.currencySymbol) {
                            setCurrencySymbol(data.currencySymbol);
                            messages.push(`Currency set to '${data.currencySymbol}'.`);
                            configChanged = true;
                        } else {
                            messages.push('Currency checked (no change).');
                        }
                    } else {
                        messages.push('No currency symbol found in import file.');
                    }

                    // Import Show Total Value (Overwrite)
                    if (typeof data.showTotalValue === 'boolean') {
                        if (showTotalValue !== data.showTotalValue) {
                            setShowTotalValue(data.showTotalValue);
                            messages.push(`Show total value set to ${data.showTotalValue}.`);
                            configChanged = true;
                        } else {
                            messages.push('Show total value checked (no change).');
                        }
                    } else {
                        messages.push('No total value display setting found in import file.');
                    }

                    if (configChanged) {
                        setImportError(`Configuration import finished: ${messages.join(' ')}`);
                    } else {
                        setImportError(`Configuration import checked: No changes applied. ${messages.join(' ')}`);
                    }
                    // Optionally clear JSON area after successful import
                    // setJsonData('');

                } catch (err) {
                    console.error("Error importing config data:", err);
                    // Re-throw error
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };


            const handleDownloadJson = () => {
                clearStatusMessages();
                if (!jsonData) {
                    setExportMessage('No data in the text area to download.');
                    return;
                }
                try {
                    const element = document.createElement('a');
                    const file = new Blob([jsonData], { type: 'application/json' });
                    element.href = URL.createObjectURL(file);
                    // Suggest filename based on content (simple check)
                    const suggestedFilename = jsonData.includes('"lowStockConfig":') ? 'electronics_config.json' : 'electronics_inventory.json';
                    element.download = suggestedFilename;
                    document.body.appendChild(element); // Required for Firefox
                    element.click();
                    document.body.removeChild(element);
                    URL.revokeObjectURL(element.href); // Clean up blob URL
                    setExportMessage('JSON file download initiated!');
                } catch (err) {
                    console.error("Error downloading JSON:", err);
                    setImportError(`Error creating download: ${err.message}`);
                }
            };

            const handleCopyJson = () => {
                clearStatusMessages();
                if (!jsonData) {
                    setExportMessage('No data in the text area to copy.');
                    return;
                }
                if (navigator.clipboard && window.isSecureContext) { // Use modern clipboard API if available
                    navigator.clipboard.writeText(jsonData)
                        .then(() => setExportMessage('JSON copied to clipboard!'))
                        .catch(err => {
                            console.error('Failed to copy using navigator.clipboard:', err);
                            setImportError('Failed to copy to clipboard.');
                        });
                } else { // Fallback for older browsers/insecure contexts (less reliable)
                    try {
                        const textArea = document.createElement("textarea");
                        textArea.value = jsonData;
                        textArea.style.position = "fixed"; // Prevent scrolling to bottom
                        textArea.style.left = "-9999px";
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textArea);
                        setExportMessage('JSON copied to clipboard (using fallback method).');
                    } catch (err) {
                        console.error('Failed to copy using fallback method:', err);
                        setImportError('Failed to copy to clipboard.');
                    }
                }
            };

            // --- Settings Page Callbacks ---
            const handleAddLowStock = (category, threshold) => {
                clearStatusMessages();
                setLowStockConfig(prev => ({ ...prev, [category]: threshold }));
                setExportMessage(`Low stock threshold ${lowStockConfig[category] ? 'updated' : 'added'} for ${category}.`);
            };

            const handleRemoveLowStock = (category) => {
                clearStatusMessages();
                setLowStockConfig(prev => {
                    const updatedConfig = { ...prev };
                    delete updatedConfig[category];
                    return updatedConfig;
                });
                setExportMessage(`Low stock threshold removed for ${category}.`);
            };

            const handleEditCategory = (oldName, newName) => {
                clearStatusMessages();
                // Update category list
                setCategories(prev => prev.map(cat => cat === oldName ? newName : cat).sort());
                // Update components using the old category name
                setComponents(prev => prev.map(comp => comp.category === oldName ? { ...comp, category: newName } : comp));
                // Update low stock config if the category existed there
                if (lowStockConfig.hasOwnProperty(oldName)) {
                    setLowStockConfig(prevConfig => {
                        const newConfig = { ...prevConfig };
                        newConfig[newName] = newConfig[oldName]; // Copy threshold
                        delete newConfig[oldName]; // Remove old entry
                        return newConfig;
                    });
                }
                // If the currently selected filter was the old name, update it (or reset)
                if (selectedCategory === oldName) {
                    setSelectedCategory(newName);
                }
                setExportMessage(`Category "${oldName}" renamed to "${newName}".`);
            };

            const handleDeleteCategory = (categoryToDelete) => {
                clearStatusMessages();
                const defaultCategoryName = "Default"; // Or "Uncategorized"

                // Ensure the default category exists if we need to move items to it
                if (!categories.includes(defaultCategoryName)) {
                    setCategories(prev => [...prev, defaultCategoryName].sort());
                }

                // Remove the category from the list
                setCategories(prev => prev.filter(cat => cat !== categoryToDelete));

                // Reassign components from the deleted category to the default one
                setComponents(prev => prev.map(comp =>
                    comp.category === categoryToDelete ? { ...comp, category: defaultCategoryName } : comp
                ));

                // Remove the category from low stock config if it exists
                if (lowStockConfig.hasOwnProperty(categoryToDelete)) {
                    setLowStockConfig(prevConfig => {
                        const newConfig = { ...prevConfig };
                        delete newConfig[categoryToDelete];
                        return newConfig;
                    });
                }

                // Reset filters if the deleted category was selected
                if (selectedCategory === categoryToDelete) setSelectedCategory('all');
                // Reset low stock form if the deleted category was selected there
                // (Handled inside the SettingsView component state reset)

                setExportMessage(`Category "${categoryToDelete}" deleted. Components moved to "${defaultCategoryName}".`);
            };

            const handleAddDefaultCategory = () => {
                clearStatusMessages();
                const defaultCategoryName = "Default";
                if (!categories.includes(defaultCategoryName)) {
                    setCategories(prev => [...prev, defaultCategoryName].sort());
                    setExportMessage(`"${defaultCategoryName}" category added.`);
                } else {
                    setExportMessage(`"${defaultCategoryName}" category already exists.`);
                }
            };

            // --- Export Location & Drawers ---
            const handleExportLocations = () => {
                clearStatusMessages();
                try {
                    const locationsData = {
                        locations: locations,
                        drawers: drawers,
                        cells: cells
                    };
                    setJsonData(JSON.stringify(locationsData, null, 2));
                    setExportMessage('Locations and drawers data ready in text area below. Copy or download.');
                } catch (err) {
                    console.error("Error exporting locations:", err);
                    setImportError(`Error exporting locations: ${err.message}`);
                }
            };

            const importLocationsData = (jsonDataToImport) => {
                try {
                    const data = JSON.parse(jsonDataToImport);

                    // Validate the imported data structure
                    if (!data.locations || !Array.isArray(data.locations)) {
                        throw new Error('Invalid locations data format.');
                    }

                    // Import locations
                    if (data.locations && Array.isArray(data.locations)) {
                        setLocations(data.locations);
                    }

                    // Import drawers if available
                    if (data.drawers && Array.isArray(data.drawers)) {
                        setDrawers(data.drawers);
                    }

                    // Import cells if available
                    if (data.cells && Array.isArray(data.cells)) {
                        setCells(data.cells);
                    }

                    setImportError('Locations, drawers, and cells imported successfully!');
                } catch (err) {
                    console.error("Error importing locations data:", err);
                    throw new Error(`Invalid JSON format or data structure: ${err.message}`);
                }
            };

            const handleLocationsFileImport = (event) => {
                clearStatusMessages();
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    setJsonData(text); // Show loaded JSON in textarea
                    try {
                        importLocationsData(text);
                    } catch (err) {
                        setImportError(`Import failed: ${err.message}`);
                    }
                };
                reader.onerror = (e) => {
                    console.error("Error reading file:", e.target.error);
                    setImportError(`Error reading file: ${e.target.error}`);
                };
                reader.readAsText(file);

                // Reset file input to allow importing the same file again
                event.target.value = null;
            };

            // --- Local Storage Callbacks ---
            const handleSaveComponentsLS = () => {
                clearStatusMessages();

                if (storage.saveComponents(components)) {
                    setExportMessage('Component data force-saved to local storage.');
                } else {
                    setImportError('Error force-saving components to local storage.');
                }
            };
            const handleSaveConfigLS = () => {
                clearStatusMessages();
                const currentConfig = { categories, viewMode, lowStockConfig, currencySymbol, showTotalValue };
                if (storage.saveConfig(currentConfig)) {
                    setExportMessage('Configuration force-saved to local storage.');
                } else {
                    setImportError('Error force-saving configuration to local storage.');
                }
            };
            const handleClearLS = () => {
                clearStatusMessages();
                if (window.confirm('Are you sure you want to clear ALL inventory data and settings from local storage? This action cannot be undone.')) {
                    if (storage.clearStorage()) {
                        // Reset ALL state values to defaults
                        setComponents([]);
                        setCategories([]);
                        setLowStockConfig({});
                        setViewMode('table');
                        setSelectedCategory('all');
                        setSearchTerm('');
                        setJsonData('');
                        setImportError('');
                        setCurrencySymbol('$');
                        setShowTotalValue(false);
                        setSelectedComponents([]);

                        // Also reset locations, drawers, and cells
                        setLocations([]);
                        setDrawers([]);
                        setCells([]);

                        // Reset footprints
                        setFootprints([]);

                        setExportMessage('Local storage cleared successfully! Application state reset.');
                    } else {
                        setImportError('An error occurred while trying to clear local storage.');
                    }
                }
            };

            // --- Get Local Storage Status (for display in Settings) ---
            // This could be memoized if performance becomes an issue
            const getLocalStorageStatus = () => ({
                components: !!localStorage.getItem('electronicsComponents'),
                categories: !!localStorage.getItem('electronicsCategories'),
                viewMode: !!localStorage.getItem('electronicsViewMode'),
                lowStockConfig: !!localStorage.getItem('electronicsLowStockConfig'),
                currencySymbol: !!localStorage.getItem('electronicsCurrencySymbol'),
                showTotalValue: !!localStorage.getItem('electronicsShowTotalValue'),
            });


            // --- Render ---
            return (
                React.createElement('div', { className: "container mx-auto p-4 font-sans" },
                    React.createElement('h1', { className: "text-3xl font-bold mb-6 text-center text-gray-700" }, "Electronics Component Inventory"),
                    React.createElement('h4', { className: "text font-bold mb-6 text-center text-gray-700" }, "DANP-EDNA V0.1.6beta"),
                    // --- Navigation Tabs ---
                    React.createElement('div', { className: "flex justify-center mb-6 border-b border-gray-300 overflow-x-auto" },
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('inventory');
                                setViewingDrawerId(null); // Reset drawer view when changing page
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'inventory' ? 'border-b-2 border-blue-500 text-blue-600 font-semibold' : 'text-gray-500 hover:text-gray-700'}`
                        }, "Inventory List"),
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('locations');
                                setViewingDrawerId(null); // Reset drawer view when changing page
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'locations' ? 'border-b-2 border-blue-500 text-blue-600 font-semibold' : 'text-gray-500 hover:text-gray-700'}`
                        }, "Locations"),
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('drawers');
                                setViewingDrawerId(null); // Reset drawer view when changing page
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'drawers' ? 'border-b-2 border-blue-500 text-blue-600 font-semibold' : 'text-gray-500 hover:text-gray-700'}`
                        }, "Drawers"),
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('data');
                                setViewingDrawerId(null); // Reset drawer view when changing page
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'data' ? 'border-b-2 border-blue-500 text-blue-600 font-semibold' : 'text-gray-500 hover:text-gray-700'}`
                        }, "Settings"),
                    ),
                    // --- Conditional Page Rendering ---
                    currentPage === 'inventory' && React.createElement(InventoryView, {
                        // Pass state
                        components: components,
                        categories: categories,
                        viewMode: viewMode,
                        selectedCategory: selectedCategory,
                        searchTerm: searchTerm,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        selectedComponents: selectedComponents,
                        locations: locations,
                        selectedLocation: selectedLocation,
                        // Pass callbacks
                        onAddComponent: handleAddComponent,
                        onEditComponent: handleEditComponent,
                        onDeleteComponent: handleDeleteComponent,
                        onUpdateQuantity: handleUpdateQuantity,
                        onToggleSelect: handleToggleSelect,
                        onToggleSelectAll: handleToggleSelectAll,
                        onBulkEdit: handleBulkEdit,
                        onBulkDelete: handleBulkDelete,
                        onChangeViewMode: setViewMode,
                        onChangeCategoryFilter: setSelectedCategory,
                        onChangeSearchTerm: setSearchTerm,
                        onChangeLocationFilter: setSelectedLocation,
                        onToggleFavorite: handleToggleFavorite,
                    }),

                    currentPage === 'data' && React.createElement(SettingsView, {
                        // Pass state
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        jsonData: jsonData,
                        importError: importError,
                        exportMessage: exportMessage,
                        localStorageStatus: getLocalStorageStatus(), // Pass LS status
                        footprints: footprints,
                        locations: locations,
                        components: components,
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        // Pass callbacks
                        onExportComponents: handleExportComponents,
                        onExportConfig: handleExportConfig,
                        onImportComponentsFile: (e) => handleFileImport(e, 'components'),
                        onImportConfigFile: (e) => handleFileImport(e, 'config'),
                        onDownloadJson: handleDownloadJson,
                        onExportLocations: handleExportLocations,
                        onImportLocationsFile: handleLocationsFileImport,
                        onCopyJson: handleCopyJson,
                        onClearJsonArea: () => { setJsonData(''); clearStatusMessages(); },
                        onChangeCurrency: (e) => { setCurrencySymbol(e.target.value); clearStatusMessages(); },
                        onChangeShowTotalValue: (e) => { setShowTotalValue(e.target.checked); clearStatusMessages(); },
                        onAddLowStock: handleAddLowStock,
                        onRemoveLowStock: handleRemoveLowStock,
                        onEditCategory: handleEditCategory,
                        onDeleteCategory: handleDeleteCategory,
                        onAddDefaultCategory: handleAddDefaultCategory,
                        onSaveComponentsLS: handleSaveComponentsLS,
                        onSaveConfigLS: handleSaveConfigLS,
                        onClearLS: handleClearLS,
                        onAddFootprint: handleAddFootprint,
                        onEditFootprint: handleEditFootprint,
                        onDeleteFootprint: handleDeleteFootprint,
                        onEditComponent: handleEditComponent,
                        onRestoreDefaultFootprints: handleRestoreDefaultFootprints,
                    }),

                    currentPage === 'locations' && React.createElement(LocationPage, {
                        locations: locations,
                        components: components,
                        drawers: drawers,
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: handleNavigateToDrawer // Add this prop
                    }),

                    // Add to the conditional page rendering section
                    currentPage === 'drawers' && React.createElement(DrawerPage, {
                        locations: locations,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        components: components,
                        initialDrawerId: viewingDrawerId, // Add this prop
                        onAddDrawer: handleAddDrawer,
                        onEditDrawer: handleEditDrawer,
                        onDeleteDrawer: handleDeleteDrawer,
                        onAddCell: handleAddCell,
                        onEditCell: handleEditCell,
                        onDeleteCell: handleDeleteCell,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: (drawerId) => setViewingDrawerId(drawerId),
                    }),

                    // --- Modals (Rendered conditionally based on state) ---
                    showForm && React.createElement(ComponentForm, {
                        componentData: editComponentData,
                        categories: categories,
                        footprints: footprints,
                        locations: locations,
                        drawers: drawers, // Add drawers
                        cells: cells,    // Add cells
                        currencySymbol: currencySymbol,
                        onSave: handleSaveComponent,
                        onCancel: () => { setShowForm(false); setEditComponentData(null); },
                        isEditMode: !!editComponentData?.id
                    }),

                    // Update this code in the render part of index.html where BulkEditForm is used

                    showBulkEditForm && React.createElement(BulkEditForm, {
                        categories: categories,
                        commonFootprints: footprints,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        selectedCount: selectedComponents.length,
                        onApply: handleApplyBulkEdit,
                        onCancel: () => setShowBulkEditForm(false)
                    })

                ) // End Main Container Div
            ); // End Main Return
        }; // End ElectronicsInventory Component

        // --- Render the Application ---
        // Ensure the root element exists before rendering
        const rootElement = document.getElementById('root');
        if (rootElement) {
            ReactDOM.render(React.createElement(ElectronicsInventory), rootElement);
        } else {
            console.error("Root element (#root) not found in the DOM.");
        }

    </script>

</body>

</html>