<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electronics Inventory (Modular)</title>
    <!--
    <script crossorigin src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.5/purify.min.js">
-->
    </script>

    <script src="js/utils/sanitize-utils.js"></script>
    <script src="js/utils/ui-constants.js"></script>
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/idb.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/utils/form-helpers.js"></script>

    <script src="js/components/ComponentForm.js"></script>
    <script src="js/components/AdvancedFilters.js"></script>
    <script src="js/components/BulkEditForm.js"></script>
    <script src="js/components/InventoryView.js"></script>
    <script src="js/components/SettingsView.js"></script>
    <script src="js/components/CategoryManager.js"></script>
    <script src="js/components/FootprintManager.js"></script>
    <script src="js/components/LocationManager.js"></script>
    <script src="js/components/LocationPage.js"></script>
    <script src="js/components/DrawerManager.js"></script>
    <script src="js/components/DrawerView.js"></script>
    <script src="js/components/DrawerPage.js"></script>
    <script src="js/components/ThemeSwitcher.js"></script>
    <script src="js/components/shared/LocationSelector.js"></script>
    <script src="js/components/shared/Pagination.js"></script>
    <script src="js/components/shared/SelectWithCustom.js"></script>
    <script src="js/components/shared/ValidatedInput.js"></script>

    <script src="js/external/tailwind.js"></script>
    <script src="js/external/react18.development.js"></script>
    <script src="js/external/react-dom18.development.js"></script>
    <script src="js/external/babel.min.js"></script>
    <script src="js/external/purify325.min.js"></script>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        // Ensure App namespace and sub-namespaces exist
        window.App = window.App || {};
        window.App.utils = window.App.utils || {};
        window.App.components = window.App.components || {};

        // Destructure React hooks and loaded components/utils for easier use
        const { useState, useEffect, useCallback } = React;
        const { helpers } = window.App.utils;
        const { storage } = window.App.utils;
        const { UI } = window.App.utils || {};
        const { ComponentForm, BulkEditForm, InventoryView, SettingsView, DrawerPage, LocationPage } = window.App.components;

        // --- Main Application Component ---
        const ElectronicsInventory = () => {
            // --- State Variables ---
            const [components, setComponents] = useState([]);
            const [categories, setCategories] = useState([]);
            const [currentPage, setCurrentPage] = useState('inventory'); // 'inventory', 'locations', 'data', or 'drawers'
            const [viewMode, setViewMode] = useState('table'); // 'table' or 'card'
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            const [showForm, setShowForm] = useState(false); // For add/edit component modal
            const [editComponentData, setEditComponentData] = useState(null); // Data for the component being edited/added
            const [jsonData, setJsonData] = useState(''); // For import/export text area
            const [importError, setImportError] = useState(''); // Message after import attempt
            const [exportMessage, setExportMessage] = useState(''); // Message after export/save attempt
            const [lowStockConfig, setLowStockConfig] = useState({}); // { category: threshold }
            const [currencySymbol, setCurrencySymbol] = useState('RM');
            const [showTotalValue, setShowTotalValue] = useState(false);
            const [selectedComponents, setSelectedComponents] = useState([]); // Array of selected component IDs for bulk actions
            const [showBulkEditForm, setShowBulkEditForm] = useState(false);
            const [locations, setLocations] = useState([]);
            const [selectedLocation, setSelectedLocation] = useState('all');
            const [footprints, setFootprints] = useState([]);
            const [drawers, setDrawers] = useState([]);
            const [cells, setCells] = useState([]);
            const [viewingDrawerId, setViewingDrawerId] = useState(null);
            const [itemsPerPage, setItemsPerPage] = useState('all');
            const [appTheme, setAppTheme] = useState(window.App.utils.UI.currentTheme);
            const [configLoaded, setConfigLoaded] = useState(false);
            const [theme, setTheme] = useState(
                () => storage.loadConfig().theme
                    || window.App.utils.UI.currentTheme
                    || 'light'
            );

            // --- Effects ---
            // Initial load effect
            useEffect(() => {
                console.log("Initial load effect running with proper data ordering...");

                // Initialize storage first
                storage.init()
                    .then(function () {
                        console.log("Storage system initialized");

                        // Load all data from IndexedDB
                        // Load all data from IndexedDB
                        Promise.all([
                            storage.loadComponents(),
                            storage.loadLocations(),
                            storage.loadDrawers(),
                            storage.loadCells(),
                            storage.loadCategories(),
                            storage.loadFootprints(),
                            storage.loadLowStockConfig()
                        ])
                            .then(function (results) {
                                var [
                                    loadedComponents,
                                    loadedLocations,
                                    loadedDrawers,
                                    loadedCells,
                                    loadedCategories,
                                    loadedFootprints,
                                    loadedLowStockConfig
                                ] = results;

                                console.log("Loaded all data:", {
                                    components: loadedComponents.length,
                                    locations: loadedLocations.length,
                                    drawers: loadedDrawers.length,
                                    cells: loadedCells.length,
                                    categories: loadedCategories.length,
                                    footprints: loadedFootprints.length,
                                    lowStockConfig: Object.keys(loadedLowStockConfig).length + " categories"
                                });

                                // Set state - THIS WAS MISSING!
                                setComponents(loadedComponents);
                                setLocations(loadedLocations);
                                setDrawers(loadedDrawers);
                                setCells(loadedCells);
                                setCategories(loadedCategories);
                                setFootprints(loadedFootprints);
                                setLowStockConfig(loadedLowStockConfig);

                                // Load other config from localStorage
                                var config = storage.loadConfig();
                                setViewMode(config.viewMode || 'table');
                                setCurrencySymbol(config.currencySymbol || 'RM');
                                setShowTotalValue(config.showTotalValue || false);
                                setItemsPerPage(config.itemsPerPage || 'all');
                                setTheme(config.theme || 'light');

                                // IMPORTANT: Mark config as loaded
                                setConfigLoaded(true);
                            });
                    });
            }, []);// Only run once

            setTimeout(() => {
                console.log("=== FINAL STATE CHECK ===");
                console.log("Components:", components.length);
                console.log("Locations:", locations.length);
                console.log("Categories:", categories.length);
            }, 100);

            // --- FOR COMPONENTS ---
            useEffect(() => {
                if (!components.length) return;

                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving components...", components.length);

                    storage.saveComponents(components)
                        .then(function (success) {
                            if (success) {
                                console.log("Components saved successfully");
                            } else {
                                console.warn("Failed to save components");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving components:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [components]);

            // --- FOR LOCATIONS ---
            useEffect(() => {
                if (!locations.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving locations...", locations.length);

                    storage.saveLocations(locations)
                        .then(function (success) {
                            if (success) {
                                console.log("Locations saved successfully");

                                // After locations are saved, make sure drawers are also saved
                                // to ensure references are maintained
                                if (drawers.length) {
                                    return storage.saveDrawers(drawers);
                                }
                            } else {
                                console.warn("Failed to save locations");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving locations:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [locations]);

            // --- FOR DRAWERS ---
            useEffect(() => {
                if (!drawers.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving drawers...", drawers.length);

                    storage.saveDrawers(drawers)
                        .then(function (success) {
                            if (success) {
                                console.log("Drawers saved successfully");

                                // After drawers are saved, make sure cells are also saved
                                // to ensure references are maintained
                                if (cells.length) {
                                    return storage.saveCells(cells);
                                }
                            } else {
                                console.warn("Failed to save drawers");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving drawers:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [drawers, cells]);

            // --- FOR CELLS ---
            useEffect(() => {
                if (!cells.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving cells...", cells.length);

                    storage.saveCells(cells)
                        .then(function (success) {
                            if (success) {
                                console.log("Cells saved successfully");
                            } else {
                                console.warn("Failed to save cells");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving cells:", err);
                        });
                }, 300);
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [cells]);

            // --- FOR CATEGORY ---
            useEffect(() => {
                if (!categories.length) return;
                storage.saveCategories(categories)
                    .then(function (success) {
                        if (success) {
                            console.log("Categories saved to IndexedDB successfully:", categories.length);
                        } else {
                            console.warn("Failed to save categories to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving categories to IndexedDB:", err);
                    });
            }, [categories]);

            // --- FOR FOOTPRINT ---
            useEffect(() => {
                if (!footprints.length) return;

                // Save directly to IndexedDB
                storage.saveFootprints(footprints)
                    .then(function (success) {
                        if (success) {
                            console.log("Footprints saved to IndexedDB successfully:", footprints.length);
                        } else {
                            console.warn("Failed to save footprints to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving footprints to IndexedDB:", err);
                    });
            }, [footprints]);

            // ---LOW CONFIG---
            useEffect(() => {
                // Skip if empty
                if (!lowStockConfig || Object.keys(lowStockConfig).length === 0) return;

                // Save to IndexedDB only
                storage.saveLowStockConfig(lowStockConfig)
                    .then(function (success) {
                        if (success) {
                            console.log("Low stock config saved to IndexedDB successfully");
                        } else {
                            console.warn("Failed to save low stock config to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving low stock config to IndexedDB:", err);
                    });
            }, [lowStockConfig]);

            // ---SAVE CONFIG---
            // For configuration (still synchronous)
            useEffect(() => {
                // Don't save until config is loaded
                if (!configLoaded) return;

                var config = {
                    categories,
                    viewMode,
                    lowStockConfig,
                    currencySymbol,
                    showTotalValue,
                    footprints,
                    itemsPerPage,
                    theme
                };

                var success = storage.saveConfig(config);
                if (success) {
                    console.log("Config saved to localStorage");
                } else {
                    console.warn("Failed to save config");
                }
            }, [configLoaded, categories, viewMode, lowStockConfig, currencySymbol, showTotalValue, footprints, itemsPerPage, theme]);

            const saveConfigCallback = useCallback(() => {
                // To IndexedDB
                Promise.all([
                    storage.saveCategories(categories),
                    storage.saveFootprints(footprints),
                    storage.saveLowStockConfig(lowStockConfig)
                ]).catch(function (err) {
                    console.error("Error saving to IndexedDB:", err);
                });
                // Config to localStorage
                storage.saveConfig({
                    viewMode,
                    currencySymbol,
                    showTotalValue,
                    itemsPerPage,
                    theme
                });
            }, [categories, footprints, lowStockConfig, viewMode, currencySymbol, showTotalValue, itemsPerPage, theme]);

            const saveComponentsCallback = useCallback(() => {
                storage.saveComponents(components);
            }, [components]);

            const handleItemsPerPageChange = useCallback((value) => {
                setItemsPerPage(value);
            }, []);

            useEffect(() => {
                // Apply theme through the UI system
                window.App.utils.UI.setTheme(theme);

                // Save theme preference (handled inside setTheme too, but for extra safety)
                localStorage.setItem('electronicsTheme', theme);

                // Log theme change for debugging
                console.log(`Theme applied: ${theme}`);
            }, [theme]);


            // --- Helper Functions / Callbacks for Child Components ---
            // Get Theme
            const getThemeColors = () => {
                // Check if UI and getThemeColors exist
                if (UI && typeof UI.getThemeColors === 'function') {
                    return UI.getThemeColors();
                }
                // Fallback if UI is not available
                return {
                    textPrimary: 'gray-900',
                    textSecondary: 'gray-700',
                    textMuted: 'gray-500',
                    primary: 'blue-500',
                    border: 'gray-300',
                    background: 'gray-100'
                };
            };

            // Get the theme colors
            const themeColors = getThemeColors();

            // --- Component CRUD Callbacks ---
            const handleAddComponent = () => {
                //clearStatusMessages();
                // Prepare initial data for the form (empty component)
                setEditComponentData({
                    id: '', name: '', category: '', customCategory: '', type: '', quantity: 0, price: 0,
                    footprint: '', customFootprint: '', parameters: '', info: '', datasheets: '', image: ''
                });
                setShowForm(true);
            };

            const handleEditComponent = (componentToEdit) => {
                //clearStatusMessages();

                // Create a deep copy of the component
                const cleanComponent = { ...componentToEdit };

                // Ensure locationInfo is a proper object
                if (!cleanComponent.locationInfo ||
                    typeof cleanComponent.locationInfo === 'string' ||
                    cleanComponent.locationInfo === '[object Object]') {
                    cleanComponent.locationInfo = { locationId: '', details: '' };
                }

                // Ensure storageInfo is a proper object
                if (!cleanComponent.storageInfo ||
                    typeof cleanComponent.storageInfo === 'string' ||
                    cleanComponent.storageInfo === '[object Object]') {
                    cleanComponent.storageInfo = { locationId: '', drawerId: '', cells: [] };
                } else {
                    // Handle partial storageInfo objects that might be missing the cells array
                    cleanComponent.storageInfo = {
                        locationId: cleanComponent.storageInfo.locationId || '',
                        drawerId: cleanComponent.storageInfo.drawerId || '',
                        cells: Array.isArray(cleanComponent.storageInfo.cells)
                            ? cleanComponent.storageInfo.cells
                            : []
                    };

                    // Handle backward compatibility - if cellId exists but cells array doesn't include it
                    if (cleanComponent.storageInfo.cellId &&
                        !cleanComponent.storageInfo.cells.includes(cleanComponent.storageInfo.cellId)) {
                        cleanComponent.storageInfo.cells.push(cleanComponent.storageInfo.cellId);
                    }
                }

                // Ensure flag fields exist
                cleanComponent.favorite = cleanComponent.favorite || false;
                cleanComponent.bookmark = cleanComponent.bookmark || false;
                cleanComponent.star = cleanComponent.star || false;

                // Determine if the footprint is custom
                const isCustomFootprint = cleanComponent.footprint &&
                    !footprints.includes(cleanComponent.footprint);

                // Prepare data for the form, formatting parameters
                setEditComponentData({
                    ...cleanComponent,
                    price: Number(cleanComponent.price) || 0, // Ensure price is number
                    quantity: Number(cleanComponent.quantity) || 0, // Ensure quantity is number
                    customCategory: '', // Reset custom field initially
                    // Set footprint dropdown value and custom input value
                    footprint: isCustomFootprint ? '__custom__' : (cleanComponent.footprint || ''),
                    customFootprint: isCustomFootprint ? cleanComponent.footprint : '',
                    // Format additional parameters for the textarea
                    parameters: helpers.formatParametersForEdit(cleanComponent)
                });
                setShowForm(true);
            };

            // Update to handleSaveComponent
            const handleSaveComponent = (componentDataFromForm) => {
                //clearStatusMessages();
                let categoryToSave = componentDataFromForm.category;
                let footprintToSave = componentDataFromForm.footprint;
                let newCategoryAdded = false;

                // Handle custom category
                if (componentDataFromForm.category === '__custom__' && componentDataFromForm.customCategory) {
                    categoryToSave = componentDataFromForm.customCategory.trim();
                    if (categoryToSave && !categories.includes(categoryToSave)) {
                        setCategories(prev => [...prev, categoryToSave].sort());
                        newCategoryAdded = true; // Mark that we might need to revert if save fails
                    } else if (!categoryToSave) {
                        // Handle case where custom is selected but input is empty
                        alert("New category name cannot be empty.");
                        return; // Prevent saving
                    }
                }

                // Handle custom footprint
                if (componentDataFromForm.footprint === '__custom__' && componentDataFromForm.customFootprint) {
                    footprintToSave = componentDataFromForm.customFootprint.trim();
                    if (!footprintToSave) {
                        alert("Custom footprint name cannot be empty.");
                        if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave)); // Revert category add if needed
                        return; // Prevent saving
                    }
                } else if (componentDataFromForm.footprint === '__custom__') {
                    // Custom selected but input empty - treat as no footprint selected
                    footprintToSave = '';
                }

                // Basic validation
                if (!componentDataFromForm.name || !categoryToSave) {
                    alert("Component Name and Category are required.");
                    // Revert category addition if validation fails
                    if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave));
                    return;
                }

                // Ensure locationInfo is properly formatted
                let locationInfo = componentDataFromForm.locationInfo;
                if (!locationInfo || typeof locationInfo === 'string' || locationInfo === '[object Object]') {
                    locationInfo = { locationId: '', details: '' };
                }

                // Process the storage information
                let storageInfo = componentDataFromForm.storageInfo;
                if (!storageInfo || typeof storageInfo === 'string' || storageInfo === '[object Object]') {
                    storageInfo = { locationId: '', drawerId: '', cells: [] };
                }

                // Ensure we store storage information properly
                const finalStorageInfo = {
                    locationId: storageInfo.locationId || '',
                    drawerId: storageInfo.drawerId || '',
                    cells: Array.isArray(storageInfo.cells) ? storageInfo.cells : []
                };

                // For backward compatibility with older components
                if (storageInfo.cellId && !finalStorageInfo.cells.includes(storageInfo.cellId)) {
                    finalStorageInfo.cells.push(storageInfo.cellId);
                }

                // Prepare the final component object
                const finalComponent = {
                    // Core fields
                    id: componentDataFromForm.id || helpers.generateId(), // Generate ID if new
                    name: componentDataFromForm.name.trim(),
                    favorite: componentDataFromForm.favorite || false,
                    bookmark: componentDataFromForm.bookmark || false,
                    star: componentDataFromForm.star || false,
                    category: categoryToSave,
                    type: componentDataFromForm.type.trim(),
                    quantity: parseInt(componentDataFromForm.quantity, 10) || 0,
                    price: parseFloat(componentDataFromForm.price) || 0,
                    footprint: footprintToSave,
                    info: (componentDataFromForm.info || '').trim(),
                    datasheets: componentDataFromForm.datasheets.trim(),
                    image: componentDataFromForm.image.trim(),
                    // Add location and storage information
                    locationInfo: locationInfo,
                    storageInfo: finalStorageInfo
                };

                // Add additional parameters, but filter out any special fields that might have been incorrectly included
                const additionalParams = helpers.parseParameters(componentDataFromForm.parameters);
                // Remove any properties that would conflict with core properties
                Object.keys(additionalParams).forEach(key => {
                    if (finalComponent.hasOwnProperty(key)) {
                        console.warn(`Parameter '${key}' conflicts with a core property and will be ignored.`);
                        delete additionalParams[key];
                    }
                });
                // Now add the filtered parameters
                Object.assign(finalComponent, additionalParams);

                // Update state: either replace existing or add new
                if (componentDataFromForm.id) { // Editing existing component
                    setComponents(prev => prev.map(comp =>
                        comp.id === componentDataFromForm.id ? finalComponent : comp
                    ));
                } else { // Adding new component
                    setComponents(prev => [...prev, finalComponent]);
                }

                // Close form and reset edit state
                setShowForm(false);
                setEditComponentData(null);
                setExportMessage(componentDataFromForm.id ? 'Component updated.' : 'Component added.');
            };

            const handleDeleteComponent = (idToDelete) => {
                //clearStatusMessages();
                if (window.confirm('Are you sure you want to delete this component? This action cannot be undone.')) {
                    setComponents(prev => prev.filter(comp => comp.id !== idToDelete));
                    // Also remove from selection if it was selected
                    setSelectedComponents(prev => prev.filter(selId => selId !== idToDelete));
                    setExportMessage('Component deleted.');
                }
            };

            const handleUpdateQuantity = (id, delta) => {
                // No need to clear messages for this frequent action
                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        const currentQuantity = Number(comp.quantity) || 0;
                        // Prevent quantity from going below zero
                        return { ...comp, quantity: Math.max(0, currentQuantity + delta) };
                    }
                    return comp;
                }));
            };

            const handleToggleFavorite = (id, property) => {
                if (!['favorite', 'bookmark', 'star'].includes(property)) return;

                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        // Toggle the property
                        return {
                            ...comp,
                            [property]: !(comp[property] || false)
                        };
                    }
                    return comp;
                }));
            };

            useEffect(() => {
                storage.saveLocations(locations);
            }, [locations]);

            // --- Bulk Action Callbacks ---
            const handleToggleSelect = (id) => {
                setSelectedComponents(prev =>
                    prev.includes(id) ? prev.filter(selId => selId !== id) : [...prev, id]
                );
            };

            const handleToggleSelectAll = () => {
                // Filter components based on current view filters *before* selecting all
                const currentlyFilteredIds = components
                    .filter(component => {
                        const matchesCategory = selectedCategory === 'all' || component.category === selectedCategory;
                        const lowerSearchTerm = searchTerm.toLowerCase();
                        const matchesSearch = !searchTerm ||
                            (component.name && component.name.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.type && component.type.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.category && component.category.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.info && component.info.toLowerCase().includes(lowerSearchTerm));
                        return matchesCategory && matchesSearch;
                    })
                    .map(comp => comp.id);

                if (selectedComponents.length === currentlyFilteredIds.length && currentlyFilteredIds.length > 0) {
                    // If all filtered are selected, deselect all
                    setSelectedComponents([]);
                } else {
                    // Otherwise, select all filtered
                    setSelectedComponents(currentlyFilteredIds);
                }
            };

            const handleBulkEdit = () => {
                //clearStatusMessages();
                if (selectedComponents.length === 0) return;
                setShowBulkEditForm(true); // Open the bulk edit modal
            };

            const handleApplyBulkEdit = (bulkEditData) => {
                //clearStatusMessages();
                let categoryToApply = bulkEditData.category;
                let footprintToApply = bulkEditData.footprint;
                let newCategoryAdded = false;

                // Handle custom category from bulk edit
                if (bulkEditData.category === '__custom__' && bulkEditData.customCategory) {
                    categoryToApply = bulkEditData.customCategory.trim();
                    if (categoryToApply && !categories.includes(categoryToApply)) {
                        setCategories(prev => [...prev, categoryToApply].sort());
                        newCategoryAdded = true;
                    } else if (!categoryToApply) {
                        // Don't apply if custom is selected but name is empty
                        categoryToApply = ''; // Effectively means "keep existing"
                    }
                }

                // Handle custom footprint from bulk edit
                if (bulkEditData.footprint === '__custom__' && bulkEditData.customFootprint) {
                    footprintToApply = bulkEditData.customFootprint.trim();
                    if (!footprintToApply) footprintToApply = ''; // Treat empty custom as no change
                } else if (bulkEditData.footprint === '__custom__') {
                    footprintToApply = ''; // Treat empty custom as no change
                }

                setComponents(prevComponents => prevComponents.map(comp => {
                    // Apply changes only to selected components
                    if (selectedComponents.includes(comp.id)) {
                        const updates = {};

                        // Apply Category (if specified and valid)
                        if (categoryToApply && categoryToApply !== '__custom__') {
                            updates.category = categoryToApply;
                        }

                        // Apply Type (if specified)
                        if (bulkEditData.type.trim()) {
                            updates.type = bulkEditData.type.trim();
                        }

                        // Apply Footprint (if specified and valid)
                        if (footprintToApply && footprintToApply !== '__custom__') {
                            updates.footprint = footprintToApply;
                        }

                        // Apply Quantity Adjustment
                        if (bulkEditData.quantity !== '' && !isNaN(bulkEditData.quantity)) {
                            const changeValue = parseInt(bulkEditData.quantity, 10) || 0;
                            const currentQuantity = Number(comp.quantity) || 0;
                            if (bulkEditData.quantityAction === 'set') {
                                updates.quantity = Math.max(0, changeValue);
                            } else if (bulkEditData.quantityAction === 'increment') {
                                updates.quantity = currentQuantity + changeValue;
                            } else if (bulkEditData.quantityAction === 'decrement') {
                                updates.quantity = Math.max(0, currentQuantity - changeValue);
                            }
                        }

                        // Apply Price Adjustment
                        if (bulkEditData.price !== '' && !isNaN(bulkEditData.price)) {
                            const priceChangeValue = parseFloat(bulkEditData.price) || 0;
                            const currentPrice = Number(comp.price) || 0;
                            if (bulkEditData.priceAction === 'set') {
                                updates.price = Math.max(0, priceChangeValue); // Ensure non-negative
                            } else if (bulkEditData.priceAction === 'increase') {
                                updates.price = Math.max(0, currentPrice + priceChangeValue);
                            } else if (bulkEditData.priceAction === 'decrease') {
                                updates.price = Math.max(0, currentPrice - priceChangeValue);
                            }
                        }

                        // Apply Favorite status (if defined)
                        if (bulkEditData.favorite !== null) {
                            updates.favorite = bulkEditData.favorite;
                        }

                        // Apply Bookmark status (if defined)
                        if (bulkEditData.bookmark !== null) {
                            updates.bookmark = bulkEditData.bookmark;
                        }

                        // Apply Star status (if defined)
                        if (bulkEditData.star !== null) {
                            updates.star = bulkEditData.star;
                        }

                        // --- Apply Location Updates ---

                        // Initialize locationInfo if needed
                        if (!comp.locationInfo || typeof comp.locationInfo === 'string' || comp.locationInfo === '[object Object]') {
                            comp.locationInfo = { locationId: '', details: '' };
                        }

                        // Handle location changes
                        if (bulkEditData.locationAction === 'clear') {
                            // Clear location information
                            updates.locationInfo = { locationId: '', details: '' };
                        } else if (bulkEditData.locationAction === 'set' && bulkEditData.locationId) {
                            // Set to a new location
                            updates.locationInfo = {
                                locationId: bulkEditData.locationId,
                                details: bulkEditData.locationDetails || ''
                            };
                        }

                        // --- Apply Storage/Drawer/Cell Updates ---

                        // Initialize storageInfo if needed
                        if (!comp.storageInfo || typeof comp.storageInfo === 'string' || comp.storageInfo === '[object Object]') {
                            comp.storageInfo = { locationId: '', drawerId: '', cells: [] };
                        } else if (!Array.isArray(comp.storageInfo.cells)) {
                            comp.storageInfo.cells = [];
                        }

                        // Handle storage actions
                        if (bulkEditData.storageAction === 'clear') {
                            // Clear drawer assignment
                            updates.storageInfo = {
                                locationId: '',
                                drawerId: '',
                                cells: []
                            };
                        } else if (bulkEditData.storageAction === 'set') {
                            // Set to new drawer and cells
                            if (bulkEditData.storageLocationId) {
                                const newStorageInfo = {
                                    locationId: bulkEditData.storageLocationId,
                                    drawerId: bulkEditData.drawerId || '',
                                    cells: bulkEditData.drawerId ? bulkEditData.selectedCells : []
                                };
                                updates.storageInfo = newStorageInfo;
                            }
                        }

                        // Return the component with applied updates
                        return { ...comp, ...updates };
                    }
                    // Return unchanged component if not selected
                    return comp;
                }));

                // Close the bulk edit form and clear selection
                setShowBulkEditForm(false);
                setSelectedComponents([]);
                setExportMessage(`${selectedComponents.length} component(s) updated.`);
            };
            const handleBulkDelete = () => {
                //clearStatusMessages();
                if (selectedComponents.length === 0) return;
                if (window.confirm(`Are you sure you want to delete ${selectedComponents.length} selected component(s)? This action cannot be undone.`)) {
                    setComponents(prev => prev.filter(comp => !selectedComponents.includes(comp.id)));
                    const deletedCount = selectedComponents.length; // Store count before clearing
                    setSelectedComponents([]); // Clear selection
                    setExportMessage(`${deletedCount} component(s) deleted.`);
                }
            };

            //-- Location Management--
            const handleAddLocation = (newLocation) => {
                //clearStatusMessages();
                setLocations(prev => [...prev, newLocation]);
                setExportMessage('Location added.');
            };

            const handleEditLocation = (locationId, updatedLocation) => {
                //clearStatusMessages();
                setLocations(prev => prev.map(loc =>
                    loc.id === locationId ? updatedLocation : loc
                ));
                setExportMessage('Location updated.');
            };

            const handleDeleteLocation = (locationId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this location
                const assignedComponents = components.filter(comp =>
                    comp.locationInfo && comp.locationInfo.locationId === locationId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This location has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the location from these components. Continue?`
                    : 'Are you sure you want to delete this location?';

                if (window.confirm(message)) {
                    // Clear location from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.locationInfo && comp.locationInfo.locationId === locationId) {
                                // Return component with cleared location
                                return {
                                    ...comp,
                                    locationInfo: null
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the location
                    setLocations(prev => prev.filter(loc => loc.id !== locationId));
                    setExportMessage(`Location deleted. ${assignedComponents.length > 0 ? `Location cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            //--Drawer Management

            // Add handlers for drawers
            const handleAddDrawer = (newDrawer) => {
                //clearStatusMessages();

                setDrawers(prev => [...prev, newDrawer]);

                const newCells = window.App.utils.helpers.generateCellsForDrawer(newDrawer);
                setCells(prev => [...prev, ...newCells]);

                setExportMessage(
                    `Drawer “${newDrawer.name}” added with ${newCells.length} empty cell${newCells.length !== 1 ? 's' : ''}.`
                );
            };

            const handleEditDrawer = (updated) => {

                setDrawers(prev => {
                    const list = prev.map(d => d.id === updated.id ? updated : d);
                    storage.saveDrawers(list);
                    return list;
                });


                setCells(prevCells => {
                    const next = window.App.utils.helpers.syncCellsWithDrawer(
                        updated,
                        prevCells,
                        components          // ← current components array from state
                    );
                    storage.saveCells(next);
                    return next;
                });
            };


            const handleDeleteDrawer = (drawerId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this drawer
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.drawerId === drawerId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This drawer has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the drawer from these components. Continue?`
                    : 'Are you sure you want to delete this drawer?';

                if (window.confirm(message)) {
                    // Clear drawer from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.drawerId === drawerId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        drawerId: '',
                                        cellId: ''  // Also clear cell if drawer is deleted
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Also delete all cells belonging to this drawer
                    setCells(prev => prev.filter(cell => cell.drawerId !== drawerId));

                    // Remove the drawer
                    setDrawers(prev => prev.filter(drawer => drawer.id !== drawerId));
                    setExportMessage(`Drawer deleted. ${assignedComponents.length > 0 ? `Drawer cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            // Add handlers for cells
            const handleAddCell = (newCell) => {
                //clearStatusMessages();
                setCells(prev => [...prev, newCell]);
                setExportMessage('Cell added.');
            };

            const handleEditCell = (cellId, updatedCell) => {
                //clearStatusMessages();
                setCells(prev => prev.map(cell =>
                    cell.id === cellId ? updatedCell : cell
                ));
                //available: existingCell.available !== undefined ? existingCell.available : true
                setExportMessage('Cell updated.');
            };

            const handleDeleteCell = (cellId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this cell
                const assignedComponents = components.filter(comp =>
                    comp.storageInfo && comp.storageInfo.cellId === cellId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This cell has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the cell from these components. Continue?`
                    : 'Are you sure you want to delete this cell?';

                if (window.confirm(message)) {
                    // Clear cell from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storageInfo && comp.storageInfo.cellId === cellId) {
                                return {
                                    ...comp,
                                    storageInfo: {
                                        ...comp.storageInfo,
                                        cellId: ''  // Clear cell but keep drawer
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the cell
                    setCells(prev => prev.filter(cell => cell.id !== cellId));
                    setExportMessage(`Cell deleted. ${assignedComponents.length > 0 ? `Cell cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            const handleNavigateToDrawer = (drawerId) => {
                setCurrentPage('drawers'); // Change to drawer page
                // You need to expose this state variable to the DrawerPage
                setViewingDrawerId(drawerId);
            };

            //-- Theme Management--
            const handleThemeChange = (newTheme) => {
                if (window.App.utils.UI.themes[newTheme]) {
                    // Update state
                    setTheme(newTheme);

                    // Get the body element
                    const bodyElement = document.body;

                    // Get theme colors
                    const themeColors = window.App.utils.UI.getThemeColors();

                    // Remove all existing theme-related classes from body
                    bodyElement.classList.remove('bg-gray-100', 'bg-gray-900');
                    bodyElement.classList.remove('text-gray-100', 'text-gray-900');

                    // Add the correct background class based on theme
                    if (newTheme === 'dark') {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    } else {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    }

                    // Update UI system
                    window.App.utils.UI.setTheme(newTheme);

                    // Save theme preference
                    saveConfigCallback();

                    // Force re-render to update components
                    setAppTheme(newTheme);
                }
            };

            // Set up global theme change handler
            window.App.onThemeChange = (newTheme) => {
                setAppTheme(newTheme);
            };

            useEffect(() => {
                // Get updated styles based on current theme
                window.App.utils.UI.buttons = window.App.utils.UI.getThemeStyles().buttons;
                window.App.utils.UI.cards = window.App.utils.UI.getThemeStyles().cards;
                window.App.utils.UI.typography = window.App.utils.UI.getThemeStyles().typography;
                // Update other style categories similarly

                // Apply theme class to body if needed
                document.body.className = `bg-${window.App.utils.UI.themes[appTheme].colors.background}`;
            }, [appTheme]);


            // --- Render ---
            return (
                React.createElement('div', { className: "container mx-auto p-4 font-sans" },
                    React.createElement('h1', {
                        className: `text-3xl font-bold mb-6 text-center text-${themeColors.textPrimary}`
                    }, "Electro Manager"),
                    React.createElement('h4', {
                        className: `text font mb-6 text-center text-${themeColors.textSecondary}`
                    }, "an Electronics Inventory System | DANP-EDNA V0.2.3beta"),
                    // Navigation Tabs
                    React.createElement('div', {
                        className: `flex justify-center mb-6 border-b border-${themeColors.border} overflow-x-auto`
                    },
                        // Inventory Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('inventory');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'inventory'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Inventory List"),

                        // Locations Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('locations');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'locations'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Locations"),

                        // Drawers Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('drawers');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'drawers'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Drawers"),

                        // Settings Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('data');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'data'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Settings")
                    ),

                    // --- Conditional Page Rendering ---
                    currentPage === 'inventory' && React.createElement(InventoryView, {
                        // Pass state
                        components: components,
                        categories: categories,
                        viewMode: viewMode,
                        selectedCategory: selectedCategory,
                        searchTerm: searchTerm,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        selectedComponents: selectedComponents,
                        drawers: drawers,
                        cells: cells,
                        locations: locations,
                        footprints: footprints,
                        selectedLocation: selectedLocation,
                        itemsPerPage: itemsPerPage,

                        // Pass callbacks
                        onAddComponent: handleAddComponent,
                        onEditComponent: handleEditComponent,
                        onDeleteComponent: handleDeleteComponent,
                        onUpdateQuantity: handleUpdateQuantity,
                        onToggleSelect: handleToggleSelect,
                        onToggleSelectAll: handleToggleSelectAll,
                        onBulkEdit: handleBulkEdit,
                        onBulkDelete: handleBulkDelete,
                        onChangeViewMode: setViewMode,
                        onChangeCategoryFilter: setSelectedCategory,
                        onChangeSearchTerm: setSearchTerm,
                        onChangeLocationFilter: setSelectedLocation,
                        onToggleFavorite: handleToggleFavorite,
                        onItemsPerPageChange: handleItemsPerPageChange,
                    }),


                    currentPage === 'data' && React.createElement(SettingsView, {
                        // Data
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        footprints: footprints,
                        components: components,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,

                        // Config
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        theme: theme,

                        // Update callbacks
                        onUpdateCategories: setCategories,
                        onUpdateLowStockConfig: setLowStockConfig,
                        onUpdateComponents: setComponents,
                        onUpdateLocations: setLocations,
                        onUpdateDrawers: setDrawers,
                        onUpdateCells: setCells,
                        onUpdateFootprints: setFootprints,

                        // Event callbacks
                        onChangeCurrency: (e) => { setCurrencySymbol(e.target.value) },
                        onChangeShowTotalValue: (e) => { setShowTotalValue(e.target.checked) },
                        onChangeTheme: handleThemeChange,

                        // Component edit callback
                        onEditComponent: handleEditComponent
                    }),

                    currentPage === 'locations' && React.createElement(LocationPage, {
                        locations: locations,
                        components: components,
                        drawers: drawers,
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: handleNavigateToDrawer // Add this prop
                    }),

                    // Add to the conditional page rendering section
                    currentPage === 'drawers' && React.createElement(DrawerPage, {
                        locations: locations,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        components: components,
                        initialDrawerId: viewingDrawerId, // Add this prop
                        onAddDrawer: handleAddDrawer,
                        onEditDrawer: handleEditDrawer,
                        onDeleteDrawer: handleDeleteDrawer,
                        onAddCell: handleAddCell,
                        onEditCell: handleEditCell,
                        onDeleteCell: handleDeleteCell,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: (drawerId) => setViewingDrawerId(drawerId),
                    }),

                    // --- Modals (Rendered conditionally based on state) ---
                    showForm && React.createElement(ComponentForm, {
                        componentData: editComponentData,
                        categories: categories,
                        footprints: footprints,
                        locations: locations,
                        drawers: drawers, // Add drawers
                        cells: cells,    // Add cells
                        currencySymbol: currencySymbol,
                        onSave: handleSaveComponent,
                        onCancel: () => { setShowForm(false); setEditComponentData(null); },
                        isEditMode: !!editComponentData?.id
                    }),

                    // Update this code in the render part of index.html where BulkEditForm is used

                    showBulkEditForm && React.createElement(BulkEditForm, {
                        categories: categories,
                        commonFootprints: footprints,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        selectedCount: selectedComponents.length,
                        onApply: handleApplyBulkEdit,
                        onCancel: () => setShowBulkEditForm(false)
                    })

                ) // End Main Container Div
            ); // End Main Return
        }; // End ElectronicsInventory Component

        // --- Render the Application ---
        // Ensure the root element exists before rendering
        const rootElement = document.getElementById('root');
        if (rootElement) {
            // Use the new createRoot API for React 18
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(ElectronicsInventory));
        } else {
            console.error("Root element (#root) not found in the DOM.");
        }
    </script>
</body>

</html>