<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electronics Inventory (Modular)</title>
    <!--
    <script crossorigin src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.5/purify.min.js">
-->
    </script>

    <script src="js/utils/ui-constants.js"></script>
    <script src="js/utils/sanitize-utils.js"></script>
    <script src="js/utils/helpers.js"></script>
    <script src="js/utils/idb.js"></script>
    <script src="js/utils/storage.js"></script>
    <script src="js/utils/form-helpers.js"></script>

    <script src="js/components/ComponentForm.js"></script>
    <script src="js/components/AdvancedFilters.js"></script>
    <script src="js/components/BulkEditForm.js"></script>
    <script src="js/components/StatisticInventory.js"></script>
    <script src="js/components/ViewTableInventory.js"></script>
    <script src="js/components/ViewCardInventory.js"></script>
 <!-- Replace existing -->
    <script src="js/components/SettingsView.js"></script>
    <script src="js/components/CategoryManager.js"></script>
    <script src="js/components/FootprintManager.js"></script>
    <script src="js/components/LocationManager.js"></script>
    <script src="js/components/LocationPage.js"></script>
    <script src="js/components/DrawerManager.js"></script>
    <script src="js/components/DrawerView.js"></script>
    <script src="js/components/DrawerPage.js"></script>
    <script src="js/components/ThemeSwitcher.js"></script>
    <script src="js/components/shared/LocationSelector.js"></script>
    <script src="js/components/shared/Pagination.js"></script>
    <script src="js/components/shared/SelectWithCustom.js"></script>
    <script src="js/components/shared/ValidatedInput.js"></script>
    <script src="js/components/InventoryView.js"></script>

    <script src="js/external/tailwind.js"></script>
    <script src="js/external/react18.development.js"></script>
    <script src="js/external/react-dom18.development.js"></script>
    <script src="js/external/babel.min.js"></script>
    <script src="js/external/purify325.min.js"></script>
</head>

<body>
    <div id="root"></div>
    <script type="text/babel">
        // Ensure App namespace and sub-namespaces exist
        window.App = window.App || {};
        window.App.utils = window.App.utils || {};
        window.App.components = window.App.components || {};

        // Destructure React hooks and loaded components/utils for easier use
        const { useState, useEffect, useCallback } = React;
        const { helpers } = window.App.utils;
        const { storage } = window.App.utils;
        const { UI } = window.App.utils || {};
        const { ComponentForm, BulkEditForm, InventoryView, SettingsView, DrawerPage, LocationPage } = window.App.components;

        // --- Main Application Component ---
        const ElectronicsInventory = () => {
            // --- State Variables ---
            const [components, setComponents] = useState([]);
            const [categories, setCategories] = useState([]);
            const [currentPage, setCurrentPage] = useState('inventory'); // 'inventory', 'locations', 'data', or 'drawers'
            const [viewMode, setViewMode] = useState('table'); // 'table' or 'card'
            const [selectedCategory, setSelectedCategory] = useState('all');
            const [searchTerm, setSearchTerm] = useState('');
            const [showForm, setShowForm] = useState(false); // For add/edit component modal
            const [editComponentData, setEditComponentData] = useState(null); // Data for the component being edited/added
            const [jsonData, setJsonData] = useState(''); // For import/export text area
            const [importError, setImportError] = useState(''); // Message after import attempt
            const [exportMessage, setExportMessage] = useState(''); // Message after export/save attempt
            const [lowStockConfig, setLowStockConfig] = useState({}); // { category: threshold }
            const [currencySymbol, setCurrencySymbol] = useState('RM');
            const [showTotalValue, setShowTotalValue] = useState(false);
            const [selectedComponents, setSelectedComponents] = useState([]); // Array of selected component IDs for bulk actions
            const [showBulkEditForm, setShowBulkEditForm] = useState(false);
            const [locations, setLocations] = useState([]);
            const [selectedLocation, setSelectedLocation] = useState('all');
            const [footprints, setFootprints] = useState([]);
            const [drawers, setDrawers] = useState([]);
            const [cells, setCells] = useState([]);
            const [viewingDrawerId, setViewingDrawerId] = useState(null);
            const [itemsPerPage, setItemsPerPage] = useState('all');
            const [appTheme, setAppTheme] = useState(window.App.utils.UI.currentTheme);
            const [configLoaded, setConfigLoaded] = useState(false);
            const [theme, setTheme] = useState(
                () => storage.loadConfig().theme
                    || window.App.utils.UI.currentTheme
                    || 'light'
            );

            // --- Effects ---
            // Initial load effect
            useEffect(() => {
                console.log("Initial load effect running with proper data ordering...");

                // Initialize storage first
                storage.init()
                    .then(function () {
                        console.log("Storage system initialized");

                        // Load all data from IndexedDB
                        Promise.all([
                            storage.loadComponents(),
                            storage.loadLocations(),
                            storage.loadDrawers(),
                            storage.loadCells(),
                            storage.loadCategories(),
                            storage.loadFootprints(),
                            storage.loadLowStockConfig()
                        ])
                            .then(function (results) {
                                var [
                                    loadedComponents,
                                    loadedLocations,
                                    loadedDrawers,
                                    loadedCells,
                                    loadedCategories,
                                    loadedFootprints,
                                    loadedLowStockConfig
                                ] = results;

                                // Set state - THIS WAS MISSING!
                                setComponents(loadedComponents);
                                setLocations(loadedLocations);
                                setDrawers(loadedDrawers);
                                setCells(loadedCells);
                                setCategories(loadedCategories);
                                setFootprints(loadedFootprints);
                                setLowStockConfig(loadedLowStockConfig);

                                // Load other config from localStorage
                                var config = storage.loadConfig();
                                setViewMode(config.viewMode || 'table');
                                setCurrencySymbol(config.currencySymbol || 'RM');
                                setShowTotalValue(config.showTotalValue || false);
                                setItemsPerPage(config.itemsPerPage || 'all');
                                setTheme(config.theme || 'light');

                                // IMPORTANT: Mark config as loaded
                                setConfigLoaded(true);
                            });
                    });
            }, []);// Only run once

            // --- FOR COMPONENTS ---
            useEffect(() => {
                if (!components.length) return;

                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving components...", components.length);

                    storage.saveComponents(components)
                        .then(function (success) {
                            if (success) {
                                console.log("Components saved successfully");
                            } else {
                                console.warn("Failed to save components");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving components:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [components]);

            // --- FOR LOCATIONS ---
            useEffect(() => {
                if (!locations.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving locations...", locations.length);

                    storage.saveLocations(locations)
                        .then(function (success) {
                            if (success) {
                                console.log("Locations saved successfully");

                                // After locations are saved, make sure drawers are also saved
                                // to ensure references are maintained
                                if (drawers.length) {
                                    return storage.saveDrawers(drawers);
                                }
                            } else {
                                console.warn("Failed to save locations");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving locations:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [locations]);

            // --- FOR DRAWERS ---
            useEffect(() => {
                if (!drawers.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving drawers...", drawers.length);

                    storage.saveDrawers(drawers)
                        .then(function (success) {
                            if (success) {
                                console.log("Drawers saved successfully");

                                // After drawers are saved, make sure cells are also saved
                                // to ensure references are maintained
                                if (cells.length) {
                                    return storage.saveCells(cells);
                                }
                            } else {
                                console.warn("Failed to save drawers");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving drawers:", err);
                        });
                }, 300); // Small delay to batch rapid changes

                // Clear timeout on unmount
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [drawers, cells]);

            // --- FOR CELLS ---
            useEffect(() => {
                if (!cells.length) return;
                // We use a delay to avoid multiple rapid saves during initialization
                var saveTimeout = setTimeout(function () {
                    console.log("Saving cells...", cells.length);

                    storage.saveCells(cells)
                        .then(function (success) {
                            if (success) {
                                console.log("Cells saved successfully");
                            } else {
                                console.warn("Failed to save cells");
                            }
                        })
                        .catch(function (err) {
                            console.error("Error saving cells:", err);
                        });
                }, 300);
                return function cleanup() {
                    clearTimeout(saveTimeout);
                };
            }, [cells]);

            // --- FOR CATEGORY ---
            useEffect(() => {
                if (!categories.length) return;
                storage.saveCategories(categories)
                    .then(function (success) {
                        if (success) {
                            console.log("Categories saved to IndexedDB successfully:", categories.length);
                        } else {
                            console.warn("Failed to save categories to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving categories to IndexedDB:", err);
                    });
            }, [categories]);

            // --- FOR FOOTPRINT ---
            useEffect(() => {
                if (!footprints.length) return;

                // Save directly to IndexedDB
                storage.saveFootprints(footprints)
                    .then(function (success) {
                        if (success) {
                            console.log("Footprints saved to IndexedDB successfully:", footprints.length);
                        } else {
                            console.warn("Failed to save footprints to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving footprints to IndexedDB:", err);
                    });
            }, [footprints]);

            // ---LOW CONFIG---
            useEffect(() => {
                // Skip if empty
                if (!lowStockConfig || Object.keys(lowStockConfig).length === 0) return;

                // Save to IndexedDB only
                storage.saveLowStockConfig(lowStockConfig)
                    .then(function (success) {
                        if (success) {
                            console.log("Low stock config saved to IndexedDB successfully");
                        } else {
                            console.warn("Failed to save low stock config to IndexedDB");
                        }
                    })
                    .catch(function (err) {
                        console.error("Error saving low stock config to IndexedDB:", err);
                    });
            }, [lowStockConfig]);

            // ---SAVE CONFIG---
            // For configuration (still synchronous)
            useEffect(() => {
                // Don't save until config is loaded
                if (!configLoaded) return;

                var config = {
                    categories,
                    viewMode,
                    lowStockConfig,
                    currencySymbol,
                    showTotalValue,
                    footprints,
                    itemsPerPage,
                    theme
                };

                var success = storage.saveConfig(config);
                if (success) {
                    console.log("Config saved to localStorage");
                } else {
                    console.warn("Failed to save config");
                }
            }, [configLoaded, categories, viewMode, lowStockConfig, currencySymbol, showTotalValue, footprints, itemsPerPage, theme]);

            const saveConfigCallback = useCallback(() => {
                // To IndexedDB
                Promise.all([
                    storage.saveCategories(categories),
                    storage.saveFootprints(footprints),
                    storage.saveLowStockConfig(lowStockConfig)
                ]).catch(function (err) {
                    console.error("Error saving to IndexedDB:", err);
                });
                // Config to localStorage
                storage.saveConfig({
                    viewMode,
                    currencySymbol,
                    showTotalValue,
                    itemsPerPage,
                    theme
                });
            }, [categories, footprints, lowStockConfig, viewMode, currencySymbol, showTotalValue, itemsPerPage, theme]);

            const saveComponentsCallback = useCallback(() => {
                storage.saveComponents(components);
            }, [components]);

            const handleItemsPerPageChange = useCallback((value) => {
                setItemsPerPage(value);
            }, []);

            useEffect(() => {
                // Apply theme through the UI system
                window.App.utils.UI.setTheme(theme);

                // Save theme preference (handled inside setTheme too, but for extra safety)
                localStorage.setItem('electronicsTheme', theme);

                // Log theme change for debugging
                console.log(`Theme applied: ${theme}`);
            }, [theme]);

            // --- Helper Functions / Callbacks for Child Components ---
            // Get Theme
            const getThemeColors = () => {
                // Check if UI and getThemeColors exist
                if (UI && typeof UI.getThemeColors === 'function') {
                    return UI.getThemeColors();
                }
                // Fallback if UI is not available
                return {
                    textPrimary: 'gray-900',
                    textSecondary: 'gray-700',
                    textMuted: 'gray-500',
                    primary: 'blue-500',
                    border: 'gray-300',
                    background: 'gray-100'
                };
            };

            // Get the theme colors
            const themeColors = getThemeColors();

            // --- Component CRUD Callbacks ---
            const handleAddComponent = () => {
                // Prepare initial data for the form (empty component)
                // FIXED: Don't generate ID here - let handleSaveComponent do it
                setEditComponentData({
                    // Remove the id field completely for new components
                    name: '',
                    category: '',
                    customCategory: '',
                    type: '',
                    quantity: 0,
                    price: 0,
                    footprint: '',
                    customFootprint: '',
                    parameters: '',
                    info: '',
                    datasheets: '',
                    image: '',
                    storage: { locationId: '', details: '', drawerId: '', cells: [] },
                    favorite: false,
                    bookmark: false,
                    star: false
                });
                setShowForm(true);
            };
            const handleEditComponent = (componentToEdit) => {
                //clearStatusMessages();

                // Create a deep copy of the component
                const cleanComponent = { ...componentToEdit };
                // Ensure storage is properly formatted
                if (!cleanComponent.storage || typeof cleanComponent.storage !== 'object') {
                    cleanComponent.storage = { locationId: '', details: '', drawerId: '', cells: [] };
                }

                // Ensure storage has all required fields
                cleanComponent.storage = {
                    locationId: cleanComponent.storage.locationId || '',
                    details: cleanComponent.storage.details || '',
                    drawerId: cleanComponent.storage.drawerId || '',
                    cells: Array.isArray(cleanComponent.storage.cells) ? cleanComponent.storage.cells : []
                };


                // Ensure flag fields exist
                cleanComponent.favorite = cleanComponent.favorite || false;
                cleanComponent.bookmark = cleanComponent.bookmark || false;
                cleanComponent.star = cleanComponent.star || false;

                // Determine if the footprint is custom
                const isCustomFootprint = cleanComponent.footprint &&
                    !footprints.includes(cleanComponent.footprint);

                // Prepare data for the form
                setEditComponentData({
                    ...cleanComponent,
                    customCategory: '',
                    footprint: isCustomFootprint ? '__custom__' : (cleanComponent.footprint || ''),
                    customFootprint: isCustomFootprint ? cleanComponent.footprint : '',
                    parameters: helpers.formatParametersForEdit(cleanComponent)
                });
                setShowForm(true);
            };

            // In index.html, update your handleSaveComponent function:

            const handleSaveComponent = (componentDataFromForm) => {
                console.log("=== handleSaveComponent called ===");
                console.log("componentDataFromForm:", componentDataFromForm);
                console.log("componentDataFromForm.ap:", componentDataFromForm.ap);

                let categoryToSave = componentDataFromForm.category;
                let footprintToSave = componentDataFromForm.footprint;
                let newCategoryAdded = false;

                // Handle custom category
                if (componentDataFromForm.category === '__custom__' && componentDataFromForm.customCategory) {
                    categoryToSave = componentDataFromForm.customCategory.trim();
                    console.log("Custom category detected:", categoryToSave);

                    if (categoryToSave && !categories.includes(categoryToSave)) {
                        console.log("Adding new category:", categoryToSave);
                        setCategories(prev => {
                            const newCategories = [...prev, categoryToSave].sort();
                            console.log("New categories array:", newCategories);
                            return newCategories;
                        });
                        newCategoryAdded = true;
                    } else if (!categoryToSave) {
                        alert("New category name cannot be empty.");
                        return;
                    }
                }

                // Handle custom footprint
                if (componentDataFromForm.footprint === '__custom__' && componentDataFromForm.customFootprint) {
                    footprintToSave = componentDataFromForm.customFootprint.trim();
                    if (!footprintToSave) {
                        alert("Custom footprint name cannot be empty.");
                        if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave));
                        return;
                    }
                } else if (componentDataFromForm.footprint === '__custom__') {
                    footprintToSave = '';
                }

                // Basic validation
                if (!componentDataFromForm.name || !categoryToSave) {
                    alert("Component Name and Category are required.");
                    if (newCategoryAdded) setCategories(cats => cats.filter(c => c !== categoryToSave));
                    return;
                }

                // FIXED: Determine if this is truly a new component or an edit
                const isEditing = editComponentData && editComponentData.id &&
                    components.some(comp => comp.id === editComponentData.id);

                console.log("Is editing existing component?", isEditing);
                console.log("Original editComponentData:", editComponentData);

                // Prepare the final component object
                const finalComponent = {
                    // FIXED: Only use existing ID if we're actually editing, otherwise generate new
                    id: isEditing ? editComponentData.id : helpers.generateId(),
                    name: componentDataFromForm.name.trim(),
                    favorite: componentDataFromForm.favorite || false,
                    bookmark: componentDataFromForm.bookmark || false,
                    star: componentDataFromForm.star || false,
                    category: categoryToSave,
                    type: componentDataFromForm.type ? componentDataFromForm.type.trim() : '',
                    quantity: parseInt(componentDataFromForm.quantity, 10) || 0,
                    price: parseFloat(componentDataFromForm.price) || 0,
                    footprint: footprintToSave,
                    info: (componentDataFromForm.info || '').trim(),
                    datasheets: componentDataFromForm.datasheets ? componentDataFromForm.datasheets.trim() : '',
                    image: componentDataFromForm.image ? componentDataFromForm.image.trim() : '',
                    // Storage field
                    storage: componentDataFromForm.storage || { locationId: '', details: '', drawerId: '', cells: [] },
                    // Add the parsed additional parameters
                    ap: componentDataFromForm.ap || []
                };

                console.log("Final component to save:", finalComponent);
                console.log("Current components array length:", components.length);
                console.log("Final component ap field:", finalComponent.ap);

                // Update state: either replace existing or add new
                if (isEditing) { // Editing existing component
                    console.log("Editing existing component:", finalComponent.id);
                    setComponents(prev => {
                        const updated = prev.map(comp =>
                            comp.id === finalComponent.id ? finalComponent : comp
                        );
                        console.log("Updated components array:", updated);
                        return updated;
                    });
                } else { // Adding new component
                    console.log("Adding new component");
                    setComponents(prev => {
                        const newArray = [...prev, finalComponent];
                        console.log("New components array:", newArray);
                        console.log("New components array length:", newArray.length);
                        return newArray;
                    });
                }

                // Close form and reset edit state
                setShowForm(false);
                setEditComponentData(null);
                setExportMessage(isEditing ? 'Component updated.' : 'Component added.');

                console.log("=== handleSaveComponent completed ===");
            };
            const handleDeleteComponent = (idToDelete) => {
                //clearStatusMessages();
                if (window.confirm('Are you sure you want to delete this component? This action cannot be undone.')) {
                    setComponents(prev => prev.filter(comp => comp.id !== idToDelete));
                    // Also remove from selection if it was selected
                    setSelectedComponents(prev => prev.filter(selId => selId !== idToDelete));
                    setExportMessage('Component deleted.');
                }
            };

            const handleUpdateQuantity = (id, delta) => {
                // No need to clear messages for this frequent action
                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        const currentQuantity = Number(comp.quantity) || 0;
                        // Prevent quantity from going below zero
                        return { ...comp, quantity: Math.max(0, currentQuantity + delta) };
                    }
                    return comp;
                }));
            };

            const handleToggleFavorite = (id, property) => {
                if (!['favorite', 'bookmark', 'star'].includes(property)) return;

                setComponents(prev => prev.map(comp => {
                    if (comp.id === id) {
                        // Toggle the property
                        return {
                            ...comp,
                            [property]: !(comp[property] || false)
                        };
                    }
                    return comp;
                }));
            };

            useEffect(() => {
                storage.saveLocations(locations);
            }, [locations]);

            // --- Bulk Action Callbacks ---
            const handleToggleSelect = (id) => {
                setSelectedComponents(prev =>
                    prev.includes(id) ? prev.filter(selId => selId !== id) : [...prev, id]
                );
            };

            const handleToggleSelectAll = () => {
                // Filter components based on current view filters *before* selecting all
                const currentlyFilteredIds = components
                    .filter(component => {
                        const matchesCategory = selectedCategory === 'all' || component.category === selectedCategory;
                        const lowerSearchTerm = searchTerm.toLowerCase();
                        const matchesSearch = !searchTerm ||
                            (component.name && component.name.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.type && component.type.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.category && component.category.toLowerCase().includes(lowerSearchTerm)) ||
                            (component.info && component.info.toLowerCase().includes(lowerSearchTerm));
                        return matchesCategory && matchesSearch;
                    })
                    .map(comp => comp.id);

                if (selectedComponents.length === currentlyFilteredIds.length && currentlyFilteredIds.length > 0) {
                    // If all filtered are selected, deselect all
                    setSelectedComponents([]);
                } else {
                    // Otherwise, select all filtered
                    setSelectedComponents(currentlyFilteredIds);
                }
            };

            const handleBulkEdit = () => {
                //clearStatusMessages();
                if (selectedComponents.length === 0) return;
                setShowBulkEditForm(true); // Open the bulk edit modal
            };

            // In index.html, replace the handleApplyBulkEdit function with this:

            const handleApplyBulkEdit = (bulkEditData) => {
                console.log("=== handleApplyBulkEdit called ===");
                console.log("bulkEditData:", bulkEditData);
                console.log("selectedComponents:", selectedComponents);

                // Apply bulk edit logic directly here instead of using external function
                let categoryToApply = bulkEditData.category;
                let footprintToApply = bulkEditData.footprint;
                let newCategoryAdded = false;
                let newCategory = null;

                // Handle custom category from bulk edit
                if (bulkEditData.category === '__custom__' && bulkEditData.customCategory) {
                    categoryToApply = bulkEditData.customCategory.trim();
                    if (categoryToApply && !categories.includes(categoryToApply)) {
                        newCategory = categoryToApply;
                        newCategoryAdded = true;
                        console.log("Adding new category:", newCategory);
                    } else if (!categoryToApply) {
                        categoryToApply = '';
                    }
                }

                // Handle custom footprint from bulk edit
                if (bulkEditData.footprint === '__custom__' && bulkEditData.customFootprint) {
                    footprintToApply = bulkEditData.customFootprint.trim();
                    if (!footprintToApply) footprintToApply = '';
                } else if (bulkEditData.footprint === '__custom__') {
                    footprintToApply = '';
                }

                // Apply changes to components
                const updatedComponents = components.map(comp => {
                    // Apply changes only to selected components
                    if (selectedComponents.includes(comp.id)) {
                        const updates = {};

                        console.log("Updating component:", comp.id);

                        // Apply Category (if specified and valid)
                        if (categoryToApply && categoryToApply !== '__custom__') {
                            updates.category = categoryToApply;
                        }

                        // Apply Type (if specified)
                        if (bulkEditData.type && bulkEditData.type.trim()) {
                            updates.type = bulkEditData.type.trim();
                        }

                        // Apply Footprint (if specified and valid)
                        if (footprintToApply && footprintToApply !== '__custom__') {
                            updates.footprint = footprintToApply;
                        }

                        // Apply Quantity Adjustment
                        if (bulkEditData.quantity !== '' && !isNaN(bulkEditData.quantity)) {
                            const changeValue = parseInt(bulkEditData.quantity, 10) || 0;
                            const currentQuantity = Number(comp.quantity) || 0;
                            if (bulkEditData.quantityAction === 'set') {
                                updates.quantity = Math.max(0, changeValue);
                            } else if (bulkEditData.quantityAction === 'increment') {
                                updates.quantity = currentQuantity + changeValue;
                            } else if (bulkEditData.quantityAction === 'decrement') {
                                updates.quantity = Math.max(0, currentQuantity - changeValue);
                            }
                        }

                        // Apply Price Adjustment
                        if (bulkEditData.price !== '' && !isNaN(bulkEditData.price)) {
                            const priceChangeValue = parseFloat(bulkEditData.price) || 0;
                            const currentPrice = Number(comp.price) || 0;
                            if (bulkEditData.priceAction === 'set') {
                                updates.price = Math.max(0, priceChangeValue);
                            } else if (bulkEditData.priceAction === 'increase') {
                                updates.price = Math.max(0, currentPrice + priceChangeValue);
                            } else if (bulkEditData.priceAction === 'decrease') {
                                updates.price = Math.max(0, currentPrice - priceChangeValue);
                            }
                        }

                        // Apply Favorite status (if defined)
                        if (bulkEditData.favorite !== null) {
                            updates.favorite = bulkEditData.favorite;
                        }

                        // Apply Bookmark status (if defined)
                        if (bulkEditData.bookmark !== null) {
                            updates.bookmark = bulkEditData.bookmark;
                        }

                        // Apply Star status (if defined)
                        if (bulkEditData.star !== null) {
                            updates.star = bulkEditData.star;
                        }

                        // FIXED: Apply Storage Updates with unified system
                        if (bulkEditData.storageAction === 'clear') {
                            updates.storage = { locationId: '', details: '', drawerId: '', cells: [] };
                            console.log("Clearing storage for component:", comp.id);
                        } else if (bulkEditData.storageAction === 'set' && bulkEditData.storage) {
                            // Only update if there's actually storage data
                            if (bulkEditData.storage.locationId || bulkEditData.storage.drawerId) {
                                updates.storage = {
                                    locationId: bulkEditData.storage.locationId || '',
                                    details: bulkEditData.storage.details || '',
                                    drawerId: bulkEditData.storage.drawerId || '',
                                    cells: Array.isArray(bulkEditData.storage.cells) ? bulkEditData.storage.cells : []
                                };
                                console.log("Setting storage for component:", comp.id, updates.storage);
                            }
                        }

                        console.log("Applied updates:", updates);

                        // Return the component with applied updates
                        return { ...comp, ...updates };
                    }
                    // Return unchanged component if not selected
                    return comp;
                });

                console.log("Updated components:", updatedComponents);

                // Update components state
                setComponents(updatedComponents);

                // If a new category was added, update categories list
                if (newCategory) {
                    setCategories(prev => [...prev, newCategory].sort());
                    console.log("Added new category:", newCategory);
                }

                // Close the bulk edit form and clear selection
                setShowBulkEditForm(false);
                setSelectedComponents([]);
                setExportMessage(`${selectedComponents.length} component(s) updated.`);

                console.log("=== handleApplyBulkEdit completed ===");
            };


            const handleBulkDelete = () => {
                //clearStatusMessages();
                if (selectedComponents.length === 0) return;
                if (window.confirm(`Are you sure you want to delete ${selectedComponents.length} selected component(s)? This action cannot be undone.`)) {
                    setComponents(prev => prev.filter(comp => !selectedComponents.includes(comp.id)));
                    const deletedCount = selectedComponents.length; // Store count before clearing
                    setSelectedComponents([]); // Clear selection
                    setExportMessage(`${deletedCount} component(s) deleted.`);
                }
            };

            //-- Location Management--
            const handleAddLocation = (newLocation) => {
                //clearStatusMessages();
                setLocations(prev => [...prev, newLocation]);
                setExportMessage('Location added.');
            };

            const handleEditLocation = (locationId, updatedLocation) => {
                //clearStatusMessages();
                setLocations(prev => prev.map(loc =>
                    loc.id === locationId ? updatedLocation : loc
                ));
                setExportMessage('Location updated.');
            };

            const handleDeleteLocation = (locationId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this location
                const assignedComponents = components.filter(comp =>
                    comp.locationInfo && comp.locationInfo.locationId === locationId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This location has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the location from these components. Continue?`
                    : 'Are you sure you want to delete this location?';

                if (window.confirm(message)) {
                    // Clear location from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.locationInfo && comp.locationInfo.locationId === locationId) {
                                // Return component with cleared location
                                return {
                                    ...comp,
                                    locationInfo: null
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the location
                    setLocations(prev => prev.filter(loc => loc.id !== locationId));
                    setExportMessage(`Location deleted. ${assignedComponents.length > 0 ? `Location cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            //--Drawer Management

            // Add handlers for drawers
            const handleAddDrawer = (newDrawer) => {
                //clearStatusMessages();

                setDrawers(prev => [...prev, newDrawer]);

                const newCells = window.App.utils.helpers.generateCellsForDrawer(newDrawer);
                setCells(prev => [...prev, ...newCells]);

                setExportMessage(
                    `Drawer “${newDrawer.name}” added with ${newCells.length} empty cell${newCells.length !== 1 ? 's' : ''}.`
                );
            };

            const handleEditDrawer = (updated) => {

                setDrawers(prev => {
                    const list = prev.map(d => d.id === updated.id ? updated : d);
                    storage.saveDrawers(list);
                    return list;
                });


                setCells(prevCells => {
                    const next = window.App.utils.helpers.syncCellsWithDrawer(
                        updated,
                        prevCells,
                        components          // ← current components array from state
                    );
                    storage.saveCells(next);
                    return next;
                });
            };


            const handleDeleteDrawer = (drawerId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this drawer
                const assignedComponents = components.filter(comp =>
                    ccomp.storage && comp.storage.drawerId === drawerId
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This drawer has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the drawer from these components. Continue?`
                    : 'Are you sure you want to delete this drawer?';

                if (window.confirm(message)) {
                    // Clear drawer from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storage && comp.storage.drawerId === drawerId) {
                                return {
                                    ...comp,
                                    storage: {
                                        ...comp.storage,
                                        drawerId: '',
                                        cellId: ''  // Also clear cell if drawer is deleted
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Also delete all cells belonging to this drawer
                    setCells(prev => prev.filter(cell => cell.drawerId !== drawerId));

                    // Remove the drawer
                    setDrawers(prev => prev.filter(drawer => drawer.id !== drawerId));
                    setExportMessage(`Drawer deleted. ${assignedComponents.length > 0 ? `Drawer cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            // Add handlers for cells
            const handleAddCell = (newCell) => {
                //clearStatusMessages();
                setCells(prev => [...prev, newCell]);
                setExportMessage('Cell added.');
            };

            const handleEditCell = (cellId, updatedCell) => {
                //clearStatusMessages();
                setCells(prev => prev.map(cell =>
                    cell.id === cellId ? updatedCell : cell
                ));
                //available: existingCell.available !== undefined ? existingCell.available : true
                setExportMessage('Cell updated.');
            };

            const handleDeleteCell = (cellId) => {
                //clearStatusMessages();

                // Check if any components are assigned to this cell
                const assignedComponents = components.filter(comp =>
                    comp.storage && comp.storage.cells && comp.storage.cells.includes(cellId)
                );

                // Confirm deletion with warning if components are assigned
                const message = assignedComponents.length > 0
                    ? `This cell has ${assignedComponents.length} component(s) assigned to it. Removing it will clear the cell from these components. Continue?`
                    : 'Are you sure you want to delete this cell?';

                if (window.confirm(message)) {
                    // Clear cell from components if needed
                    if (assignedComponents.length > 0) {
                        setComponents(prev => prev.map(comp => {
                            if (comp.storage && comp.storage.cells && comp.storage.cells.includes(cellId)) {
                                return {
                                    ...comp,
                                    storage: {
                                        ...comp.storage,
                                        cellId: ''  // Clear cell but keep drawer
                                    }
                                };
                            }
                            return comp;
                        }));
                    }

                    // Remove the cell
                    setCells(prev => prev.filter(cell => cell.id !== cellId));
                    setExportMessage(`Cell deleted. ${assignedComponents.length > 0 ? `Cell cleared from ${assignedComponents.length} component(s).` : ''}`);
                }
            };

            const handleNavigateToDrawer = (drawerId) => {
                setCurrentPage('drawers'); // Change to drawer page
                // You need to expose this state variable to the DrawerPage
                setViewingDrawerId(drawerId);
            };

            //-- Theme Management--
            const handleThemeChange = (newTheme) => {
                if (window.App.utils.UI.themes[newTheme]) {
                    // Update state
                    setTheme(newTheme);

                    // Get the body element
                    const bodyElement = document.body;

                    // Get theme colors
                    const themeColors = window.App.utils.UI.getThemeColors();

                    // Remove all existing theme-related classes from body
                    bodyElement.classList.remove('bg-gray-100', 'bg-gray-900');
                    bodyElement.classList.remove('text-gray-100', 'text-gray-900');

                    // Add the correct background class based on theme
                    if (newTheme === 'dark') {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    } else {
                        bodyElement.classList.add(`bg-${themeColors.background}`);
                        bodyElement.classList.add(`text-${themeColors.textPrimary}`);
                    }

                    // Update UI system
                    window.App.utils.UI.setTheme(newTheme);

                    // Save theme preference
                    saveConfigCallback();

                    // Force re-render to update components
                    setAppTheme(newTheme);
                }
            };

            // Set up global theme change handler
            window.App.onThemeChange = (newTheme) => {
                setAppTheme(newTheme);
            };

            useEffect(() => {
                // Get updated styles based on current theme
                window.App.utils.UI.buttons = window.App.utils.UI.getThemeStyles().buttons;
                window.App.utils.UI.cards = window.App.utils.UI.getThemeStyles().cards;
                window.App.utils.UI.typography = window.App.utils.UI.getThemeStyles().typography;
                // Update other style categories similarly

                // Apply theme class to body if needed
                document.body.className = `bg-${window.App.utils.UI.themes[appTheme].colors.background}`;
            }, [appTheme]);


            // --- Render ---
            return (
                React.createElement('div', { className: "container mx-auto p-4 font-sans" },
                    React.createElement('h1', {
                        className: `text-3xl font-bold mb-6 text-center text-${themeColors.textPrimary}`
                    }, "Electro Manager"),
                    React.createElement('h4', {
                        className: `text font mb-6 text-center text-${themeColors.textSecondary}`
                    }, "an Electronics Inventory System | DANP-EDNA V0.2.73beta"),
                    // Navigation Tabs
                    React.createElement('div', {
                        className: `flex justify-center mb-6 border-b border-${themeColors.border} overflow-x-auto`
                    },
                        // Inventory Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('inventory');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'inventory'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Inventory List"),

                        // Locations Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('locations');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'locations'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Locations"),

                        // Drawers Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('drawers');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'drawers'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Drawers"),

                        // Settings Tab
                        React.createElement('button', {
                            onClick: () => {
                                setCurrentPage('data');
                                setViewingDrawerId(null);
                            },
                            className: `py-2 px-4 text-lg whitespace-nowrap ${currentPage === 'data'
                                ? `border-b-2 border-${themeColors.primary} text-${themeColors.primary} font-semibold`
                                : `text-${themeColors.textMuted} hover:text-${themeColors.textSecondary}`
                                }`
                        }, "Settings")
                    ),

                    // --- Conditional Page Rendering ---
                    currentPage === 'inventory' && React.createElement(InventoryView, {
                        // Pass state
                        components: components,
                        categories: categories,
                        viewMode: viewMode,
                        selectedCategory: selectedCategory,
                        searchTerm: searchTerm,
                        lowStockConfig: lowStockConfig,
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        selectedComponents: selectedComponents,
                        drawers: drawers,
                        cells: cells,
                        locations: locations,
                        footprints: footprints,
                        selectedLocation: selectedLocation,
                        itemsPerPage: itemsPerPage,

                        // Pass callbacks
                        onAddComponent: handleAddComponent,
                        onEditComponent: handleEditComponent,
                        onDeleteComponent: handleDeleteComponent,
                        onUpdateQuantity: handleUpdateQuantity,
                        onToggleSelect: handleToggleSelect,
                        onToggleSelectAll: handleToggleSelectAll,
                        onBulkEdit: handleBulkEdit,
                        onBulkDelete: handleBulkDelete,
                        onChangeViewMode: setViewMode,
                        onChangeCategoryFilter: setSelectedCategory,
                        onChangeSearchTerm: setSearchTerm,
                        onChangeLocationFilter: setSelectedLocation,
                        onToggleFavorite: handleToggleFavorite,
                        onItemsPerPageChange: handleItemsPerPageChange,
                    }),


                    currentPage === 'data' && React.createElement(SettingsView, {
                        // Data
                        categories: categories,
                        lowStockConfig: lowStockConfig,
                        footprints: footprints,
                        components: components,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,

                        // Config
                        currencySymbol: currencySymbol,
                        showTotalValue: showTotalValue,
                        theme: theme,

                        // Update callbacks
                        onUpdateCategories: setCategories,
                        onUpdateLowStockConfig: setLowStockConfig,
                        onUpdateComponents: setComponents,
                        onUpdateLocations: setLocations,
                        onUpdateDrawers: setDrawers,
                        onUpdateCells: setCells,
                        onUpdateFootprints: setFootprints,

                        // Event callbacks
                        onChangeCurrency: (e) => { setCurrencySymbol(e.target.value) },
                        onChangeShowTotalValue: (e) => { setShowTotalValue(e.target.checked) },
                        onChangeTheme: handleThemeChange,

                        // Component edit callback
                        onEditComponent: handleEditComponent
                    }),

                    currentPage === 'locations' && React.createElement(LocationPage, {
                        locations: locations,
                        components: components,
                        drawers: drawers,
                        onAddLocation: handleAddLocation,
                        onEditLocation: handleEditLocation,
                        onDeleteLocation: handleDeleteLocation,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: handleNavigateToDrawer // Add this prop
                    }),

                    // Add to the conditional page rendering section
                    currentPage === 'drawers' && React.createElement(DrawerPage, {
                        locations: locations,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        components: components,
                        initialDrawerId: viewingDrawerId, // Add this prop
                        onAddDrawer: handleAddDrawer,
                        onEditDrawer: handleEditDrawer,
                        onDeleteDrawer: handleDeleteDrawer,
                        onAddCell: handleAddCell,
                        onEditCell: handleEditCell,
                        onDeleteCell: handleDeleteCell,
                        onEditComponent: handleEditComponent,
                        onNavigateToDrawer: (drawerId) => setViewingDrawerId(drawerId),
                    }),

                    // --- Modals (Rendered conditionally based on state) ---
                    showForm && React.createElement(ComponentForm, {
                        componentData: editComponentData,
                        categories: categories,
                        footprints: footprints,
                        locations: locations,
                        drawers: drawers, // Add drawers
                        cells: cells,    // Add cells
                        currencySymbol: currencySymbol,
                        onSave: handleSaveComponent,
                        onCancel: () => { setShowForm(false); setEditComponentData(null); },
                        isEditMode: !!editComponentData?.id
                    }),

                    showBulkEditForm && React.createElement(BulkEditForm, {
                        categories: categories,
                        commonFootprints: footprints,
                        locations: locations,
                        drawers: drawers,
                        cells: cells,
                        selectedCount: selectedComponents.length,
                        onApply: handleApplyBulkEdit,
                        onCancel: () => setShowBulkEditForm(false)
                    })

                ) // End Main Container Div
            ); // End Main Return
        }; // End ElectronicsInventory Component

        // --- Render the Application ---
        // Ensure the root element exists before rendering
        const rootElement = document.getElementById('root');
        if (rootElement) {
            // Use the new createRoot API for React 18
            const root = ReactDOM.createRoot(rootElement);
            root.render(React.createElement(ElectronicsInventory));
        } else {
            console.error("Root element (#root) not found in the DOM.");
        }
    </script>
</body>

</html>